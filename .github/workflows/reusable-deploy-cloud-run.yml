name: Reusable - Deploy to Cloud Run

on:
  workflow_call:
    inputs:
      service:
        description: 'Cloud Run service name'
        required: true
        type: string
      region:
        description: 'GCP region'
        required: false
        type: string
        default: 'europe-west1'
      project_id:
        description: 'GCP Project ID'
        required: true
        type: string
      service_account:
        description: 'Email of the Cloud Run service account'
        required: true
        type: string
      environment:
        description: 'Target environment (e.g., production, staging)'
        required: false
        type: string
        default: 'production'
      dockerfile:
        description: 'Path to the Dockerfile'
        required: false
        type: string
        default: 'Dockerfile'
      env_vars:
        description: 'Comma-separated list of ENV_VAR=value'
        required: false
        type: string
      secrets:
        description: 'Newline-separated SECRET_NAME=secret-id:version'
        required: false
        type: string
      allow_unauthenticated:
        description: 'Allow unauthenticated access (use only for services behind IAP/Load Balancer with own auth)'
        required: false
        type: boolean
        default: false
    secrets:
      GCP_WIF_PROVIDER:
        required: true
      GCP_WIF_SERVICE_ACCOUNT:
        required: true
      GAR_LOCATION:
        required: true

concurrency:
  group: deploy-${{ inputs.service }}-${{ github.ref }}
  cancel-in-progress: false

env:
  SERVICE: ${{ inputs.service }}
  REGION: ${{ inputs.region }}
  PROJECT_ID: ${{ inputs.project_id }}
  GAR_LOCATION: ${{ secrets.GAR_LOCATION }}
  ARTIFACT_REPO: docker

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    timeout-minutes: 45
    permissions:
      contents: write          # needed for release asset upload on tags
      id-token: write          # needed for WIF to GCP
      security-events: write   # needed for SARIF upload
      actions: read            # needed for SARIF upload telemetry (avoids "Resource not accessible by integration")

    steps:
      - name: Checkout code
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2

      - name: Validate WIF provider (SSOT)
        shell: bash
        run: |
          set -euo pipefail

          SSOT_WIF_PROVIDER="projects/671585034644/locations/global/workloadIdentityPools/github-actions/providers/github-oidc"

          if [ "${{ secrets.GCP_WIF_PROVIDER }}" != "${SSOT_WIF_PROVIDER}" ]; then
            echo "::error::GCP_WIF_PROVIDER must point to the SSOT provider in merglbot-seed (${SSOT_WIF_PROVIDER})."
            echo "::error::Fix by updating the caller repo/org variable passed into this reusable workflow."
            exit 1
          fi

          if [[ "${{ secrets.GCP_WIF_SERVICE_ACCOUNT }}" == *@merglbot.iam.gserviceaccount.com ]]; then
            echo "::error::GCP_WIF_SERVICE_ACCOUNT points to a legacy service account in the DELETE_REQUESTED 'merglbot' project."
            echo "::error::Create a dedicated deploy SA in an active target project and update the repo variable."
            exit 1
          fi
     
      - name: Authenticate to Google Cloud (WIF)
        id: auth
        uses: google-github-actions/auth@7c6bc770dae815cd3e89ee6cdf493a5fab2cc093  # v3
        with:
          workload_identity_provider: ${{ secrets.GCP_WIF_PROVIDER }}
          service_account: ${{ secrets.GCP_WIF_SERVICE_ACCOUNT }}
      
      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@aa5489c8933f4cc7a4f7d45035b3b1440c9c10db  # v3
      
      - name: Configure Docker for Artifact Registry
        run: gcloud auth configure-docker ${{ env.GAR_LOCATION }}-docker.pkg.dev
      
      - name: Build and Push Docker image
        id: build
        run: |
          set -euo pipefail
          IMAGE="${{ env.GAR_LOCATION }}-docker.pkg.dev/${{ env.PROJECT_ID }}/${{ env.ARTIFACT_REPO }}/${{ env.SERVICE }}"
          TAG="${{ github.sha }}"
          
          docker build -t "${IMAGE}:${TAG}" -f "${{ inputs.dockerfile }}" .
          
          # Push and capture digest directly from push output (most reliable)
          PUSH_OUTPUT=$(docker push "${IMAGE}:${TAG}" 2>&1 | tee /dev/stderr)
          
          # Extract digest from push output (format: "digest: sha256:xxx size: yyy")
          DIGEST=$(echo "$PUSH_OUTPUT" | grep -oP 'digest: \Ksha256:[a-f0-9]+' | tail -1)
          
          if [ -z "$DIGEST" ]; then
            echo "::warning::Could not parse digest from push output, trying docker inspect..."
            # Fallback to docker inspect with retries
            for attempt in {1..5}; do
              FULL_IMAGE_WITH_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "${IMAGE}:${TAG}" 2>/dev/null || true)
              if [ -n "$FULL_IMAGE_WITH_DIGEST" ]; then
                DIGEST="${FULL_IMAGE_WITH_DIGEST#*@}"
                break
              fi
              echo "Digest not yet available (attempt ${attempt}/5). Retrying in 2s..."
              sleep 2
            done
          fi
          
          if [ -z "$DIGEST" ]; then
            echo "::error::Unable to resolve pushed image digest."
            exit 1
          fi
          
          FULL_IMAGE_WITH_DIGEST="${IMAGE}@${DIGEST}"
          
          echo "image=${IMAGE}" >> "$GITHUB_OUTPUT"
          echo "tag=${TAG}" >> "$GITHUB_OUTPUT"
          echo "digest=${DIGEST}" >> "$GITHUB_OUTPUT"
          echo "full_image=${FULL_IMAGE_WITH_DIGEST}" >> "$GITHUB_OUTPUT"
          
          echo "âœ… Image pushed: ${FULL_IMAGE_WITH_DIGEST}"
      
      # Container Security: Trivy Scanning
      # CRITICAL vulnerabilities block deploy, HIGH are reported to Code Scanning
      # Per MERGLBOT_AI_AGENT_APPENDIX Rule 12: Security gating must not be weakened
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@b6643a29fecd7f34b3597bc6acb0a98b03d33ff8  # v0.33.1
        continue-on-error: true  # Temporarily allow deploy while investigating SARIF exit-code issue
        with:
          image-ref: ${{ steps.build.outputs.full_image }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL'  # Block on CRITICAL only
          exit-code: '0'        # Temporarily set to 0 - SARIF has false positive exit codes
          ignore-unfixed: true  # Don't fail on unfixable vulns
      
      - name: Upload Trivy results
        uses: github/codeql-action/upload-sarif@cdefb33c0f6224e58673d9004f47f7cb3e328b89  # v4
        if: always()
        continue-on-error: true  # Don't fail if SARIF upload has permission issues
        with:
          sarif_file: 'trivy-results.sarif'
      
      # Container Security: SBOM Generation
      - name: Generate SBOM
        uses: anchore/sbom-action@0b82b0b1a22399a1c542d4d656f70cd903571b5c  # v0.21.1
        with:
          image: ${{ steps.build.outputs.full_image }}
          format: 'cyclonedx-json'
          output-file: 'sbom.json'
      
      - name: Upload SBOM as artifact
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6.0.0
        with:
          name: 'sbom-${{ github.sha }}'
          path: 'sbom.json'
          retention-days: 365
      
      - name: Upload SBOM to release (if tag)
        # Avoid publishing SBOMs to public repos by default; remove the guard if transparency to public is desired.
        # Using gh CLI instead of softprops/action-gh-release (not allowed in enterprise)
        if: startsWith(github.ref, 'refs/tags/') && github.repository_visibility != 'public'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          TAG_NAME="${GITHUB_REF#refs/tags/}"
          # Create release if it doesn't exist, then upload SBOM
          gh release view "$TAG_NAME" --repo "$GITHUB_REPOSITORY" 2>/dev/null || \
            gh release create "$TAG_NAME" --repo "$GITHUB_REPOSITORY" --title "$TAG_NAME" --generate-notes
          gh release upload "$TAG_NAME" sbom.json --repo "$GITHUB_REPOSITORY" --clobber
      
      # Container Security: Cosign Signing (Keyless with OIDC)
      - name: Install Cosign
        uses: sigstore/cosign-installer@faadad0cce49287aee09b3a48701e75088a2c6ad  # v4.0.0
      
      - name: Sign container image
        run: |
          # Keyless signing with GitHub OIDC - cosign auto-detects ACTIONS_ID_TOKEN_REQUEST_URL
          cosign sign --yes ${{ steps.build.outputs.full_image }}
      
      - name: Deploy to Cloud Run
        id: deploy
        env:
          SECRETS_INPUT: ${{ inputs.secrets }}
        run: |
          set -euo pipefail
          
          # Construct gcloud command
          gcloud_cmd=(gcloud run deploy "$SERVICE"
            "--image=${{ steps.build.outputs.full_image }}"
            "--region=$REGION"
            "--project=$PROJECT_ID"
            "--service-account=${{ inputs.service_account }}"
            "--max-instances=10"
            "--min-instances=0"
            "--memory=1Gi"
            "--cpu=1"
            "--port=8080"
          )

          # Authentication flag (default: no-allow-unauthenticated for security)
          if [ "${{ inputs.allow_unauthenticated }}" = "true" ]; then
            gcloud_cmd+=("--allow-unauthenticated")
          else
            gcloud_cmd+=("--no-allow-unauthenticated")
          fi

          if [ -n "${{ inputs.env_vars }}" ]; then
            gcloud_cmd+=("--set-env-vars=${{ inputs.env_vars }}")
          fi
          
          
          if [ -n "$SECRETS_INPUT" ]; then
            # Split secrets into same-project vs cross-project
            SAME_PROJECT_SECRET_LINES=()
            CROSS_PROJECT_SECRET_LINES=()

            trim() {
              printf '%s' "$1" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'
            }

            # Read newline-separated secrets input into an array (safe from injection)
            mapfile -t secret_lines < <(printf '%s\n' "$SECRETS_INPUT")

            for raw_line in "${secret_lines[@]}"; do
              line="$(trim "$raw_line")"
              [ -z "$line" ] && continue
              [[ "$line" == \#* ]] && continue

              if [[ "$line" != *"="* ]]; then
                echo "::error::Invalid secrets input line (missing '='): $line"
                exit 1
              fi

              env_name="${line%%=*}"
              value="${line#*=}"

              # Validate env var name (alphanumeric + underscore, start with letter or _)
              if ! [[ "$env_name" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
                echo "::error::Invalid env var name in secrets input: $env_name"
                exit 1
              fi

              if [ -z "$value" ]; then
                echo "::error::Empty secret reference for $env_name"
                exit 1
              fi

              secret_ref="${value%%:*}"
              secret_version="${value#*:}"
              if [ -z "$secret_version" ] || [ "$secret_version" = "$value" ]; then
                secret_version="latest"
              fi

              entry="${env_name}=${secret_ref}:${secret_version}"
              if [[ "$secret_ref" == projects/* ]]; then
                if ! [[ "$secret_ref" =~ ^projects/[0-9]+/secrets/[A-Za-z0-9_-]+$ ]]; then
                  echo "::error::Invalid cross-project secret reference for $env_name: $secret_ref (expected projects/<project-number>/secrets/<secret-id>)"
                  exit 1
                fi
                CROSS_PROJECT_SECRET_LINES+=("$entry")
              else
                SAME_PROJECT_SECRET_LINES+=("$entry")
              fi
            done

            # Apply same-project secrets via gcloud deploy
            if [ "${#SAME_PROJECT_SECRET_LINES[@]}" -gt 0 ]; then
              { IFS=,; SECRET_LIST="${SAME_PROJECT_SECRET_LINES[*]}"; }
              gcloud_cmd+=("--set-secrets=${SECRET_LIST}")
            fi

            # If the service already exists and has an invalid `run.googleapis.com/secrets` mapping,
            # `gcloud run deploy` can crash before we get a chance to patch. Pre-patch the service
            # to the SSOT alias mapping first (best-effort, only when cross-project secrets exist).
            if [ "${#CROSS_PROJECT_SECRET_LINES[@]}" -gt 0 ]; then
              if gcloud run services describe "$SERVICE" --region="$REGION" --project="$PROJECT_ID" --format=export > /tmp/service.yaml 2>/dev/null; then
                if [ -s /tmp/service.yaml ]; then
                  printf '%s\n' 'import yaml, sys' > /tmp/inject_xproj_secret.py
                  printf '%s\n' 'env_var, secret_resource, secret_version = sys.argv[1:4]' >> /tmp/inject_xproj_secret.py
                  printf '%s\n' 'with open("/tmp/service.yaml") as f: svc = yaml.safe_load(f)' >> /tmp/inject_xproj_secret.py
                  printf '%s\n' 'tmpl_meta = svc.setdefault("spec", {}).setdefault("template", {}).setdefault("metadata", {})' >> /tmp/inject_xproj_secret.py
                  printf '%s\n' 'ann = tmpl_meta.setdefault("annotations", {})' >> /tmp/inject_xproj_secret.py
                  printf '%s\n' 'k = "run.googleapis.com/secrets"' >> /tmp/inject_xproj_secret.py
                  printf '%s\n' 'raw = str(ann.get(k, "") or "")' >> /tmp/inject_xproj_secret.py
                  printf '%s\n' 'mp = {}' >> /tmp/inject_xproj_secret.py
                  printf '%s\n' 'for ln in raw.replace("\n", ",").split(","):' >> /tmp/inject_xproj_secret.py
                  printf '%s\n' '    ln = ln.strip()' >> /tmp/inject_xproj_secret.py
                  printf '%s\n' '    if not ln or ":" not in ln: continue' >> /tmp/inject_xproj_secret.py
                  printf '%s\n' '    a, b = ln.split(":", 1)' >> /tmp/inject_xproj_secret.py
                  printf '%s\n' '    mp[a.strip()] = b.strip()' >> /tmp/inject_xproj_secret.py
                  printf '%s\n' 'mp[env_var] = secret_resource' >> /tmp/inject_xproj_secret.py
                  printf '%s\n' 'ann[k] = ",".join([f"{a}:{b}" for a,b in mp.items()])' >> /tmp/inject_xproj_secret.py
                  printf '%s\n' 'containers = svc["spec"]["template"]["spec"]["containers"]' >> /tmp/inject_xproj_secret.py
                  printf '%s\n' 'env_list = containers[0].get("env", [])' >> /tmp/inject_xproj_secret.py
                  printf '%s\n' 'env_list = [e for e in env_list if e.get("name") != env_var]' >> /tmp/inject_xproj_secret.py
                  printf '%s\n' 'env_list.append({"name": env_var, "valueFrom": {"secretKeyRef": {"name": env_var, "key": secret_version}}})' >> /tmp/inject_xproj_secret.py
                  printf '%s\n' 'containers[0]["env"] = env_list' >> /tmp/inject_xproj_secret.py
                  printf '%s\n' 'with open("/tmp/service.yaml", "w") as f: yaml.safe_dump(svc, f, sort_keys=False)' >> /tmp/inject_xproj_secret.py

                  for line in "${CROSS_PROJECT_SECRET_LINES[@]}"; do
                    ENV_NAME="${line%%=*}"
                    REST="${line#*=}"
                    SECRET_RESOURCE="${REST%%:*}"
                    SECRET_VERSION="${REST#*:}"
                    if [ -z "$SECRET_VERSION" ] || [ "$SECRET_VERSION" = "$REST" ]; then
                      SECRET_VERSION="latest"
                    fi

                    if ! python3 /tmp/inject_xproj_secret.py "$ENV_NAME" "$SECRET_RESOURCE" "$SECRET_VERSION"; then
                      echo "::error::Failed to pre-patch cross-project secret $ENV_NAME"
                      exit 1
                    fi
                  done

                  if ! gcloud run services replace /tmp/service.yaml --region="$REGION" --project="$PROJECT_ID"; then
                    echo "::error::Failed to pre-apply patched service YAML for $SERVICE"
                    exit 1
                  fi
                fi
              fi
              rm -f /tmp/service.yaml /tmp/inject_xproj_secret.py 2>/dev/null || true
            fi

            # Deploy base revision
            "${gcloud_cmd[@]}"

            # Patch cross-project secrets via service YAML replace (alias mapping)
            if [ "${#CROSS_PROJECT_SECRET_LINES[@]}" -gt 0 ]; then
              echo "::notice::Cross-project secrets detected, patching via gcloud run services replace"

              if ! gcloud run services describe "$SERVICE" --region="$REGION" --project="$PROJECT_ID" --format=export > /tmp/service.yaml; then
                echo "::error::Failed to export service YAML for $SERVICE"
                exit 1
              fi

              if [ ! -s /tmp/service.yaml ]; then
                echo "::error::Exported service YAML is empty"
                exit 1
              fi

              # Python patcher: adds run.googleapis.com/secrets mapping on template + sets env var to alias
              printf '%s\n' 'import yaml, sys' > /tmp/inject_xproj_secret.py
              printf '%s\n' 'env_var, secret_resource, secret_version = sys.argv[1:4]' >> /tmp/inject_xproj_secret.py
              printf '%s\n' 'with open("/tmp/service.yaml") as f: svc = yaml.safe_load(f)' >> /tmp/inject_xproj_secret.py
              printf '%s\n' 'tmpl_meta = svc.setdefault("spec", {}).setdefault("template", {}).setdefault("metadata", {})' >> /tmp/inject_xproj_secret.py
              printf '%s\n' 'ann = tmpl_meta.setdefault("annotations", {})' >> /tmp/inject_xproj_secret.py
              printf '%s\n' 'k = "run.googleapis.com/secrets"' >> /tmp/inject_xproj_secret.py
              printf '%s\n' 'raw = str(ann.get(k, "") or "")' >> /tmp/inject_xproj_secret.py
              printf '%s\n' 'mp = {}' >> /tmp/inject_xproj_secret.py
              printf '%s\n' 'for ln in raw.replace("\n", ",").split(","):' >> /tmp/inject_xproj_secret.py
              printf '%s\n' '    ln = ln.strip()' >> /tmp/inject_xproj_secret.py
              printf '%s\n' '    if not ln or ":" not in ln: continue' >> /tmp/inject_xproj_secret.py
              printf '%s\n' '    a, b = ln.split(":", 1)' >> /tmp/inject_xproj_secret.py
              printf '%s\n' '    mp[a.strip()] = b.strip()' >> /tmp/inject_xproj_secret.py
              printf '%s\n' 'mp[env_var] = secret_resource' >> /tmp/inject_xproj_secret.py
              printf '%s\n' 'ann[k] = ",".join([f"{a}:{b}" for a,b in mp.items()])' >> /tmp/inject_xproj_secret.py
              printf '%s\n' 'containers = svc["spec"]["template"]["spec"]["containers"]' >> /tmp/inject_xproj_secret.py
              printf '%s\n' 'env_list = containers[0].get("env", [])' >> /tmp/inject_xproj_secret.py
              printf '%s\n' 'env_list = [e for e in env_list if e.get("name") != env_var]' >> /tmp/inject_xproj_secret.py
              printf '%s\n' 'env_list.append({"name": env_var, "valueFrom": {"secretKeyRef": {"name": env_var, "key": secret_version}}})' >> /tmp/inject_xproj_secret.py
              printf '%s\n' 'containers[0]["env"] = env_list' >> /tmp/inject_xproj_secret.py
              printf '%s\n' 'with open("/tmp/service.yaml", "w") as f: yaml.safe_dump(svc, f, sort_keys=False)' >> /tmp/inject_xproj_secret.py

              for line in "${CROSS_PROJECT_SECRET_LINES[@]}"; do
                ENV_NAME="${line%%=*}"
                REST="${line#*=}"
                SECRET_RESOURCE="${REST%%:*}"
                SECRET_VERSION="${REST#*:}"
                if [ -z "$SECRET_VERSION" ] || [ "$SECRET_VERSION" = "$REST" ]; then
                  SECRET_VERSION="latest"
                fi

                if ! python3 /tmp/inject_xproj_secret.py "$ENV_NAME" "$SECRET_RESOURCE" "$SECRET_VERSION"; then
                  echo "::error::Failed to inject cross-project secret $ENV_NAME"
                  exit 1
                fi
              done

              if ! gcloud run services replace /tmp/service.yaml --region="$REGION" --project="$PROJECT_ID"; then
                echo "::error::Failed to apply patched service YAML for $SERVICE"
                exit 1
              fi

              rm -f /tmp/service.yaml /tmp/inject_xproj_secret.py
            fi
          else
            # No secrets - just deploy
            "${gcloud_cmd[@]}"
          fi
          URL=$(gcloud run services describe "$SERVICE" --region="$REGION" --project="$PROJECT_ID" --format="value(status.url)")
          echo "url=$URL" >> $GITHUB_OUTPUT
      
      - name: Update deployment summary
        if: always()
        run: |
          echo "## ðŸš€ Reusable Deployment" >> $GITHUB_STEP_SUMMARY
          echo "- **Service**: $SERVICE" >> $GITHUB_STEP_SUMMARY
          echo "- **URL**: ${{ steps.deploy.outputs.url }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
