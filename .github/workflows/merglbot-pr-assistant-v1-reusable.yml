name: Merglbot PR Assistant v1 (Reusable)

on:
  workflow_call:
    inputs:
      pr_number:
        description: 'PR number (integer or full URL)'
        required: true
        type: string
      prompt:
        description: 'Custom instruction for assistant'
        required: false
        type: string
        default: |
          ProveÄ profesionÃ¡lnÃ­ code review tohoto PR. ZamÄ›Å™ se na: (1) bezpeÄnost (secrets, OIDC/WIF), (2) architekturnÃ­ konzistenci s WARP rules, (3) potenciÃ¡lnÃ­ bugy a edge cases, (4) kvalitu kÃ³du a idiomatiÄnost. OdpovÄ›z Äesky, kÃ³d komentuj anglicky. VÃ½stup: krÃ¡tkÃ½ sumÃ¡Å™ (3-5 Å™Ã¡dkÅ¯), seznam konkrÃ©tnÃ­ch findings (kaÅ¾dÃ½ s vysvÄ›tlenÃ­m a doporuÄenÃ­m), zÃ¡vÄ›r (schvÃ¡lit/changes needed).
      model:
        description: 'AI model'
        required: false
        type: string
        default: 'Sonnet 4.5 Thinking (doporuÄeno)'
      openai_model:
        description: 'OpenAI model (default: gpt-5.1 high thinking)'
        required: false
        type: string
        default: 'gpt-5.1'
      temperature:
        description: 'Sampling temperature (0.0-1.0)'
        required: false
        type: string
        default: '0.2'
      openai_temperature:
        description: 'OpenAI sampling temperature (0.0-1.0)'
        required: false
        type: string
        default: '0.2'
      openai_max_tokens:
        description: 'OpenAI max_tokens for responses'
        required: false
        type: string
        default: '4096'
      enable_openai:
        description: 'Enable OpenAI review/patch calls'
        required: false
        type: string
        default: 'true'
      run_mode:
        description: 'Run mode: suggest (comments), apply-suggestions (review suggestions), apply (commit & push)'
        required: false
        type: string
        default: 'suggest'
      allowed_paths:
        description: 'Allowed path globs (comma-separated)'
        required: false
        type: string
        default: '**'
      max_changed_lines:
        description: 'Max changed lines for apply modes'
        required: false
        type: string
        default: '800'
      patch_provider:
        description: 'Which model generates patches (claude|openai)'
        required: false
        type: string
        default: 'claude'
      confirm:
        description: 'For apply mode: type "apply" to confirm'
        required: false
        type: string
    secrets:
      ANTHROPIC_API_KEY:
        required: true
      GH_TOKEN:
        required: false
      OPENAI_API_KEY:
        required: false

  workflow_dispatch:
    inputs:
      pr_number:
        description: 'ÄŒÃ­slo PR (napÅ™. 20) NEBO plnÃ¡ URL (napÅ™. https://github.com/org/repo/pull/20)'
        required: true
        type: string
      prompt:
        description: 'VolitelnÃ¡ instrukce pro asistenta'
        required: false
        type: string
        default: |
          ProveÄ profesionÃ¡lnÃ­ code review tohoto PR. ZamÄ›Å™ se na: (1) bezpeÄnost (secrets, OIDC/WIF), (2) architekturnÃ­ konzistenci s WARP rules, (3) potenciÃ¡lnÃ­ bugy a edge cases, (4) kvalitu kÃ³du a idiomatiÄnost. OdpovÄ›z Äesky, kÃ³d komentuj anglicky. VÃ½stup: krÃ¡tkÃ½ sumÃ¡Å™ (3-5 Å™Ã¡dkÅ¯), seznam konkrÃ©tnÃ­ch findings (kaÅ¾dÃ½ s vysvÄ›tlenÃ­m a doporuÄenÃ­m), zÃ¡vÄ›r (schvÃ¡lit/changes needed).
      model:
        description: 'AI model - doporuÄeno: Sonnet 4.5 Thinking (max thinking), Opus 4.1 (komplexnÃ­), Haiku 3.5 (rychlÃ½)'
        required: false
        type: choice
        default: 'Sonnet 4.5 Thinking (doporuÄeno)'
        options:
          - Sonnet 4.5 Thinking (doporuÄeno)
          - Sonnet 4.5 (standard)
          - Opus 4.1 (komplexnÃ­)
          - Haiku 3.5 (rychlÃ½)
          - Opus 4.0
          - Sonnet 4.0
          - Sonnet 3.7
          - Sonnet 3.5 (stable)
          - Sonnet 3.5 (legacy)
          - Haiku 3.0
      openai_model:
        description: 'OpenAI model'
        required: false
        type: choice
        default: 'gpt-5.1'
        options:
          - 'gpt-5.1'
          - 'gpt-4.1'
          - 'gpt-4.1-mini'
          - 'o4'
          - 'o4-mini'
      temperature:
        description: 'Teplota vzorkovÃ¡nÃ­ (0.0-1.0, niÅ¾Å¡Ã­ = konzervativnÄ›jÅ¡Ã­ odpovÄ›di)'
        required: false
        type: number
        default: 0.2
      enable_openai:
        description: 'Povolit OpenAI review/patch'
        required: false
        type: boolean
        default: true
      run_mode:
        description: 'ReÅ¾im bÄ›hu: suggest (komentÃ¡Å™e), apply-suggestions (review nÃ¡vrhy), apply (commit & push)'
        required: true
        type: choice
        default: suggest
        options:
          - suggest
          - apply-suggestions
          - apply
      patch_provider:
        description: 'Zdroj patchÅ¯ (claude|openai)'
        required: false
        type: choice
        default: claude
        options:
          - claude
          - openai
      confirm:
        description: 'Pouze pro apply reÅ¾im: napiÅ¡ "apply" pro povolenÃ­ commit & push'
        required: false
        type: string

permissions:
  contents: write         # needed for git push (apply mode)
  pull-requests: write    # needed for comments and reviews
  id-token: write        # for WIF/OIDC (future)

concurrency:
  group: claude-assistant-v2-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  review:
    name: Claude PR Review
    runs-on: ubuntu-latest
    timeout-minutes: 15
    env:
      ANTHROPIC_API_VERSION: "2023-06-01"  # Centralized version, can be updated

    steps:
      - name: Checkout repository
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v5.0.0
        with:
          fetch-depth: 0

      - name: Parse inputs (PR and prompt)
        id: parse
        env:
          INPUT: ${{ inputs.pr_number }}
          PROMPT_INPUT: ${{ inputs.prompt }}
          RUN_MODE: ${{ inputs.run_mode }}
        run: |
          set -euo pipefail
          
          # Normalize run_mode (strip extra text if choice format)
          RUN_MODE_TRIM=$(printf "%s" "$RUN_MODE" | awk '{print $1}')
          echo "run_mode=$RUN_MODE_TRIM" >> "$GITHUB_OUTPUT"
          
          # Extract PR number from input (support both integer and URL)
          if [[ "$INPUT" =~ github\.com/.*/pull/([0-9]+) ]]; then
            PR_NUMBER="${BASH_REMATCH[1]}"
          elif [[ "$INPUT" =~ ^[0-9]+$ ]]; then
            PR_NUMBER="$INPUT"
          else
            echo "âŒ Invalid pr_number: $INPUT (expect PR integer or full URL)" >&2
            exit 1
          fi
          echo "pr_number=$PR_NUMBER" >> "$GITHUB_OUTPUT"
          
          # Prepare prompt file (no variable expansion)
          : "${PROMPT_INPUT:=Manual review requested via workflow}"
          PROMPT_FILE="$RUNNER_TEMP/prompt.txt"
          printf "%s\n" "$PROMPT_INPUT" > "$PROMPT_FILE"
          echo "prompt_file=$PROMPT_FILE" >> "$GITHUB_OUTPUT"

      - name: Prepare helper scripts
        id: helpers
        run: |
          set -euo pipefail
          
          # allowlist_to_regex: convert globs to ERE
          cat > "$RUNNER_TEMP/allowlist.sh" <<'SH'
          allowlist_to_regex() {
            # Input: comma-separated globs (e.g. "src/**,docs/**")
            # Output: single ERE joined by |
            printf "%s" "$1" | tr ',' '\n' \
              | sed -E 's/([.^$+?{}()|[\]\\])/\\\1/g; s@\*\*@.*@g; s@\*@[^/]*@g' \
              | paste -sd'|' -
          }
          SH
          
          # Python: unified-diff â†’ GitHub review suggestions
          cat > "$RUNNER_TEMP/patch_to_review.py" <<'PY'
          import re, json, sys
          # Named constants
          MAX_REVIEW_COMMENTS = 30  # GitHub API limit for review comments
          
          patch = sys.stdin.read().splitlines()
          comments = []
          current_file = None
          new_start = None
          new_count = None
          content = []

          def flush():
              if current_file and new_start is not None and content:
                  body = "".join(content)
                  count = new_count if new_count is not None else max(1, len(body.splitlines()))
                  end = new_start + count - 1
                  comments.append({
                      "path": current_file,
                      "side": "RIGHT",
                      "start_line": new_start,
                      "line": end,
                      "body": f"```suggestion\n{body}\n```",
                  })

          for line in patch:
              if line.startswith('+++ b/'):
                  current_file = line[6:]
                  continue
              if line.startswith('@@ '):
                  if content:
                      flush()
                      content = []
                  m = re.search(r"@@ -\d+(?:,\d+)? \+(\d+)(?:,(\d+))? @@", line)
                  if m:
                      new_start = int(m.group(1))
                      new_count = int(m.group(2)) if m.group(2) else None
                  else:
                      new_start, new_count = None, None
                  continue
              if line.startswith('+++') or line.startswith('--- '):
                  continue
              if line.startswith('+') and not line.startswith('+++'):
                  content.append(line[1:] + "\n")
              elif line.startswith(' ') and content:
                  content.append(line[1:] + "\n")

          if content:
              flush()

          comments = comments[:MAX_REVIEW_COMMENTS]
          json.dump(comments, sys.stdout)
          PY

      - name: Build review context (PR body, bugbots, files)
        id: context
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ steps.parse.outputs.pr_number }}
        run: |
          set -euo pipefail
          
          # Fetch metadata
          gh pr view "$PR_NUMBER" --json title,body,url,headRefName,baseRefName,author > pr_meta.json
          gh pr view "$PR_NUMBER" --json files --jq '.files[].path' > files.txt || true
          gh pr view "$PR_NUMBER" --json comments --jq '.comments[] | select(.author.login | contains("bot")) | "- " + (.author.login) + ": " + (.body | gsub("\\r"; "") | gsub("\\n"; " ") | .[0:500])' > bugbot.txt || true
          
          PR_TITLE=$(jq -r '.title // ""' pr_meta.json)
          PR_BODY=$(jq -r '.body // ""' pr_meta.json | head -c 12000)
          PR_URL=$(jq -r '.url // ""' pr_meta.json)
          HEAD=$(jq -r '.headRefName // ""' pr_meta.json)
          BASE=$(jq -r '.baseRefName // ""' pr_meta.json)
          AUTHOR=$(jq -r '.author.login // ""' pr_meta.json)
          
          {
            echo "# PR Kontext"
            echo "Title: $PR_TITLE"
            echo "URL: $PR_URL"
            echo "Author: $AUTHOR"
            echo "Head: $HEAD -> Base: $BASE"
            echo
            echo "## PR Body"
            printf "%s\n" "$PR_BODY"
            echo
            echo "## Bugbot komentÃ¡Å™e"
            if [ -s bugbot.txt ]; then
              head -n 200 bugbot.txt
            else
              echo "(Å¾Ã¡dnÃ© bot komentÃ¡Å™e)"
            fi
            echo
            echo "## Seznam souborÅ¯"
            if [ -s files.txt ]; then
              head -n 200 files.txt
            else
              echo "(neznÃ¡mÃ©)"
            fi
          } > context.txt

          # Trim context file for safety
          head -c 120000 context.txt > context.txt.trim && mv context.txt.trim context.txt
          echo "context_file=$PWD/context.txt" >> "$GITHUB_OUTPUT"

      - name: Map model name to API identifier
        id: cfg
        env:
          MODEL_INPUT: ${{ inputs.model }}
          TEMP: ${{ inputs.temperature }}
          OPENAI_MODEL_INPUT: ${{ inputs.openai_model }}
          OPENAI_TEMP: ${{ inputs.openai_temperature }}
          OPENAI_MAX: ${{ inputs.openai_max_tokens }}
          PATCH_PROVIDER_INPUT: ${{ inputs.patch_provider }}
          ALLOWED: ${{ inputs.allowed_paths }}
          MAX: ${{ inputs.max_changed_lines }}
        run: |
          set -euo pipefail
          
          # Map human-readable names to Anthropic API identifiers
          case "${MODEL_INPUT:-}" in
            "Sonnet 4.5 Thinking (doporuÄeno)") MODEL='claude-sonnet-4-5-thinking-20250929' ;;
            "Sonnet 4.5 (standard)")    MODEL='claude-sonnet-4-5-20250929' ;;
            "Opus 4.1 (komplexnÃ­)")     MODEL='claude-opus-4-1-20250805' ;;
            "Haiku 3.5 (rychlÃ½)")       MODEL='claude-3-5-haiku-20241022' ;;
            "Opus 4.0")                 MODEL='claude-opus-4-20250514' ;;
            "Sonnet 4.0")               MODEL='claude-sonnet-4-20250514' ;;
            "Sonnet 3.7")               MODEL='claude-3-7-sonnet-20250219' ;;
            "Sonnet 3.5 (stable)")      MODEL='claude-3-5-sonnet-20241022' ;;
            "Sonnet 3.5 (legacy)")      MODEL='claude-3-5-sonnet-20240620' ;;
            "Haiku 3.0")                MODEL='claude-3-haiku-20240307' ;;
            *)                          MODEL='claude-sonnet-4-5-thinking-20250929' ;;  # safe fallback
          esac

          case "${OPENAI_MODEL_INPUT:-}" in
            "gpt-5.1")       OPENAI_MODEL='gpt-5.1' ;;
            "gpt-4.1")       OPENAI_MODEL='gpt-4.1' ;;
            "gpt-4.1-mini")  OPENAI_MODEL='gpt-4.1-mini' ;;
            "o4")            OPENAI_MODEL='o4' ;;
            "o4-mini")       OPENAI_MODEL='o4-mini' ;;
            *)               OPENAI_MODEL='gpt-5.1' ;;
          esac
          
          [ -z "${TEMP:-}" ] && TEMP='0.2'
          [ -z "${OPENAI_TEMP:-}" ] && OPENAI_TEMP='0.2'
          [ -z "${OPENAI_MAX:-}" ] && OPENAI_MAX='4096'
          [ -z "${ALLOWED:-}" ] && ALLOWED='**'
          [ -z "${MAX:-}" ] && MAX='800'

          PATCH_PROVIDER=$(printf "%s" "${PATCH_PROVIDER_INPUT:-claude}" | tr '[:upper:]' '[:lower:]')
          if [ "$PATCH_PROVIDER" != "openai" ]; then
            PATCH_PROVIDER="claude"
          fi
          
          echo "model=$MODEL" >> "$GITHUB_OUTPUT"
          echo "temperature=$TEMP" >> "$GITHUB_OUTPUT"
          echo "openai_model=$OPENAI_MODEL" >> "$GITHUB_OUTPUT"
          echo "openai_temperature=$OPENAI_TEMP" >> "$GITHUB_OUTPUT"
          echo "openai_max_tokens=$OPENAI_MAX" >> "$GITHUB_OUTPUT"
          echo "patch_provider=$PATCH_PROVIDER" >> "$GITHUB_OUTPUT"
          echo "$ALLOWED" > allowed.txt
          echo "$MAX" > max.txt

      # ======================== SUGGEST MODE ========================
      - name: Build PR diff (suggest mode)
        if: steps.parse.outputs.run_mode == 'suggest'
        id: pr_ctx
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          PR_NUMBER="${{ steps.parse.outputs.pr_number }}"
          gh pr diff "$PR_NUMBER" > pr_diff.txt || echo "No diff available" > pr_diff.txt
          wc -l pr_diff.txt || true

      - name: Call LLM (suggest mode)
        if: steps.parse.outputs.run_mode == 'suggest'
        id: call_suggest
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          set -euo pipefail
          # Named constants for input size limits
          MAX_COMMENT_CHARS=20000
          MAX_DIFF_LINES=8000
          MAX_CONTEXT_CHARS=120000
          
          COMMENT=$(cat '${{ steps.parse.outputs.prompt_file }}')
          CONTEXT=$(cat '${{ steps.context.outputs.context_file }}' | head -c "$MAX_CONTEXT_CHARS")
          MODEL='${{ steps.cfg.outputs.model }}'
          TEMP='${{ steps.cfg.outputs.temperature }}'
    
          # Truncate inputs to avoid "Argument list too long" error
          COMMENT_SAFE=$(printf "%s" "$COMMENT" | head -c "$MAX_COMMENT_CHARS")
          DIFF_CONTENT=$(head -n "$MAX_DIFF_LINES" pr_diff.txt)

          if [ -z "${ANTHROPIC_API_KEY:-}" ]; then
            printf "LLM not configured; posting diff summary only." > claude_response.txt
            exit 0
          fi
    
          # Write inputs to temp files to avoid command line length limits
          printf "%s" "$COMMENT_SAFE" > /tmp/comment.txt
          printf "%s" "$DIFF_CONTENT" > /tmp/diff.txt
          
          # Build payload using file inputs (avoids "Argument list too long")
          PAYLOAD=$(jq -n \
            --arg model "$MODEL" \
            --arg temp "$TEMP" \
            --rawfile comment /tmp/comment.txt \
            --rawfile context "${{ steps.context.outputs.context_file }}" \
            --rawfile diff /tmp/diff.txt \
            '{
              "model": $model,
              "max_tokens": 4096,
              "temperature": ($temp | tonumber),
              "messages": [
                {
                  "role": "user",
                  "content": [
                    {
                      "type": "text",
                      "text": "You are a helpful code reviewer.\nRules: no secrets in logs, least-privilege IAM, safe shell patterns, no destructive infra changes.\n\nUser request:\n"
                    },
                    {
                      "type": "text",
                      "text": $comment
                    },
                    {
                      "type": "text",
                      "text": "\n\nPR Context:\n```\n"
                    },
                    {
                      "type": "text",
                      "text": $context
                    },
                    {
                      "type": "text",
                      "text": "\n```"
                    },
                    {
                      "type": "text",
                      "text": "\n\nPR Diff:\n```\n"
                    },
                    {
                      "type": "text",
                      "text": $diff
                    },
                    {
                      "type": "text",
                      "text": "\n```"
                    }
                  ]
                }
              ]
            }')

          # Write payload to file to avoid "Argument list too long" with curl -d
          printf "%s" "$PAYLOAD" > /tmp/payload.json
          
          RESP=$(curl -s https://api.anthropic.com/v1/messages \
            -H "content-type: application/json" \
            -H "x-api-key: $ANTHROPIC_API_KEY" \
            -H "anthropic-version: ${ANTHROPIC_API_VERSION:-2023-06-01}" \
            -d @/tmp/payload.json)
    
          printf "%s" "$RESP" > claude_api_suggest.json
          echo "$RESP" | jq -r '.content[0].text // ""' > claude_response.txt

      - name: Call OpenAI (suggest mode)
        if: steps.parse.outputs.run_mode == 'suggest' && inputs.enable_openai != 'false' && inputs.enable_openai != '0'
        id: call_openai_suggest
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -euo pipefail
          MAX_COMMENT_CHARS=20000
          MAX_DIFF_LINES=8000
          MAX_CONTEXT_CHARS=120000
          
          if [ -z "${OPENAI_API_KEY:-}" ]; then
            echo "OpenAI API key missing; skipping OpenAI review."
            : > openai_response.txt
            exit 0
          fi

          COMMENT=$(cat '${{ steps.parse.outputs.prompt_file }}')
          CONTEXT=$(cat '${{ steps.context.outputs.context_file }}' | head -c "$MAX_CONTEXT_CHARS")
          MODEL='${{ steps.cfg.outputs.openai_model }}'
          TEMP='${{ steps.cfg.outputs.openai_temperature }}'
          MAXTOK='${{ steps.cfg.outputs.openai_max_tokens }}'
    
          COMMENT_SAFE=$(printf "%s" "$COMMENT" | head -c "$MAX_COMMENT_CHARS")
          DIFF_CONTENT=$(head -n "$MAX_DIFF_LINES" pr_diff.txt)

          printf "%s" "$COMMENT_SAFE" > /tmp/comment.txt
          printf "%s" "$CONTEXT" > /tmp/context.txt
          printf "%s" "$DIFF_CONTENT" > /tmp/diff.txt

          PAYLOAD=$(jq -n \
            --arg model "$MODEL" \
            --arg temp "$TEMP" \
            --arg max_tok "$MAXTOK" \
            --rawfile comment /tmp/comment.txt \
            --rawfile context /tmp/context.txt \
            --rawfile diff /tmp/diff.txt \
            '{
              "model": $model,
              "temperature": ($temp | tonumber),
              "max_tokens": ($max_tok | tonumber),
              "messages": [
                {
                  "role": "system",
                  "content": "You are a helpful code reviewer. Rules: no secrets in logs, least-privilege IAM, safe shell patterns, no destructive infra changes."
                },
                {
                  "role": "user",
                  "content": ("User request:\n" + $comment + "\n\nPR Context:\n" + $context + "\n\nPR Diff:\n```\n" + $diff + "\n```")
                }
              ]
            }')

          printf "%s" "$PAYLOAD" > /tmp/openai_payload.json

          RESP=$(curl -s https://api.openai.com/v1/chat/completions \
            -H "content-type: application/json" \
            -H "authorization: Bearer $OPENAI_API_KEY" \
            -d @/tmp/openai_payload.json)
          
          printf "%s" "$RESP" | jq -r '.choices[0].message.content // ""' > openai_response.txt

      - name: Post comment (suggest mode)
        if: steps.parse.outputs.run_mode == 'suggest'
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          PR_NUMBER="${{ steps.parse.outputs.pr_number }}"
          
          CLAUDE_BODY=""
          OPENAI_BODY=""
          [ -s claude_response.txt ] && CLAUDE_BODY=$(cat claude_response.txt)
          [ -s openai_response.txt ] && OPENAI_BODY=$(cat openai_response.txt)

          if [ -z "$CLAUDE_BODY" ] && [ -z "$OPENAI_BODY" ]; then
            {
              echo "## ðŸ¤– Merglbot PR Assistant"
              echo
              echo "No suggestions generated or LLM unavailable."
            } > comment_body.md
          else
            {
              echo "## ðŸ¤– Merglbot PR Assistant"
              echo
              if [ -n "$CLAUDE_BODY" ]; then
                echo "### Claude"
                echo
                echo "$CLAUDE_BODY"
                echo
              fi
              if [ -n "$OPENAI_BODY" ]; then
                echo "### OpenAI"
                echo
                echo "$OPENAI_BODY"
                echo
              fi
              echo "---"
              echo "*AI-generated suggestions. Please review before applying.*"
            } > comment_body.md
          fi
          
          gh pr comment "$PR_NUMBER" --body-file comment_body.md

      # =============== APPLY/APPLY-SUGGESTIONS SHARED ===============
      - name: Fetch PR metadata
        if: steps.parse.outputs.run_mode != 'suggest'
        id: meta
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          PR="${{ steps.parse.outputs.pr_number }}"
          OWNER_REPO="$GITHUB_REPOSITORY"
          
          gh api repos/$OWNER_REPO/pulls/$PR > pr.json
          HEAD_REF=$(jq -r '.head.ref' pr.json)
          HEAD_REPO=$(jq -r '.head.repo.full_name' pr.json)
          BASE_REF=$(jq -r '.base.ref' pr.json)
          
          echo "head_ref=$HEAD_REF" >> "$GITHUB_OUTPUT"
          echo "head_repo=$HEAD_REPO" >> "$GITHUB_OUTPUT"
          echo "base_ref=$BASE_REF" >> "$GITHUB_OUTPUT"

      - name: Checkout PR head
        if: steps.parse.outputs.run_mode != 'suggest'
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v5.0.0
        with:
          repository: ${{ steps.meta.outputs.head_repo || github.repository }}
          ref: ${{ steps.meta.outputs.head_ref }}
          fetch-depth: 0

      - name: Build context for patch generation
        if: steps.parse.outputs.run_mode != 'suggest'
        id: ctx
        run: |
          set -euo pipefail
          BASE_REF="${{ steps.meta.outputs.base_ref }}"
          git fetch --no-tags origin "$BASE_REF":"refs/remotes/origin/$BASE_REF"
          git --no-pager diff --unified=1 "origin/$BASE_REF...HEAD" > pr_diff.txt || true
          
          echo "${{ inputs.allowed_paths }}" > allowed.txt
          echo "${{ inputs.max_changed_lines }}" > max.txt

      - name: Ask LLM for unified patch (Claude)
        if: steps.parse.outputs.run_mode != 'suggest' && steps.cfg.outputs.patch_provider == 'claude'
        id: ask
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          set -euo pipefail
          # Named constants for diff limits
          MAX_DIFF_LINES=8000
          MAX_DIFF_CHARS=350000
          MODEL='${{ steps.cfg.outputs.model }}'
          TEMP='${{ steps.cfg.outputs.temperature }}'
          PROMPT=$(cat '${{ steps.parse.outputs.prompt_file }}')
          
          escape_for_prompt() { sed -e 's/[`$\\]/\\&/g'; }
          DIFF=$(head -n "$MAX_DIFF_LINES" pr_diff.txt | escape_for_prompt | head -c "$MAX_DIFF_CHARS")
          ALLOWED=$(cat allowed.txt)
          MAX=$(cat max.txt)
          
          read -r -d '' SYS <<'EOS' || true
          You are a cautious code editor that outputs a single valid unified diff patch.
          Rules:
          - Touch ONLY files under the allowlist globs provided.
          - Never modify .github/workflows, secrets, lock files, or binary assets.
          - Keep total added+removed lines <= MAX_LINES.
          - The patch must apply cleanly with \`git apply\` from repo root.
          - Prefer minimal edits; maintain existing code style.
          - If nothing needs changing, return an empty patch.
          EOS
          
          read -r -d '' REQ <<EOF || true
          TASK:
          $PROMPT
          
          PR diff (context):
          \`\`\`diff
          $DIFF
          \`\`\`
          
          CONSTRAINTS:
          - ALLOWLIST: $ALLOWED
          - MAX_LINES: $MAX
          
          Output ONLY the unified diff. No explanatory text.
          EOF
          
          if [ -z "${ANTHROPIC_API_KEY:-}" ]; then
            : > patch.diff
            exit 0
          fi
          
          # Prepare JSON payload with system and request prompts
          PAYLOAD=$(jq -n \
            --arg model "$MODEL" \
            --arg temp "$TEMP" \
            --arg sys "$SYS" \
            --arg req "$REQ" \
            '{
              "model": $model,
              "max_tokens": 4096,
              "temperature": ($temp | tonumber),
              "messages": [
                {
                  "role": "system",
                  "content": $sys
                },
                {
                  "role": "user",
                  "content": $req
                }
              ]
            }')

          # Write payload to file to avoid "Argument list too long" with curl -d
          printf "%s" "$PAYLOAD" > /tmp/payload_apply.json
          
          RESP=$(curl -s https://api.anthropic.com/v1/messages \
            -H "content-type: application/json" \
            -H "x-api-key: $ANTHROPIC_API_KEY" \
            -H "anthropic-version: ${ANTHROPIC_API_VERSION:-2023-06-01}" \
            -d @/tmp/payload_apply.json)
          
          # Extract patch content from LLM response
          echo "$RESP" | jq -r '.content[0].text // .content // empty' > patch_raw.txt
  
          # Strip markdown code fences if present
          awk 'BEGIN{in=1} /^```/{in=!in; next} {if(in) print}' patch_raw.txt > patch.diff || true

      - name: Ask OpenAI for unified patch
        if: steps.parse.outputs.run_mode != 'suggest' && steps.cfg.outputs.patch_provider == 'openai' && inputs.enable_openai != 'false' && inputs.enable_openai != '0'
        id: ask_openai
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -euo pipefail
          MAX_DIFF_LINES=8000
          MAX_DIFF_CHARS=350000
          MODEL='${{ steps.cfg.outputs.openai_model }}'
          TEMP='${{ steps.cfg.outputs.openai_temperature }}'
          MAXTOK='${{ steps.cfg.outputs.openai_max_tokens }}'
          PROMPT=$(cat '${{ steps.parse.outputs.prompt_file }}')
          
          escape_for_prompt() { sed -e 's/[`$\\]/\\&/g'; }
          DIFF=$(head -n "$MAX_DIFF_LINES" pr_diff.txt | escape_for_prompt | head -c "$MAX_DIFF_CHARS")
          ALLOWED=$(cat allowed.txt)
          MAX=$(cat max.txt)
          
          read -r -d '' SYS <<'EOS' || true
          You are a cautious code editor that outputs a single valid unified diff patch.
          Rules:
          - Touch ONLY files under the allowlist globs provided.
          - Never modify .github/workflows, secrets, lock files, or binary assets.
          - Keep total added+removed lines <= MAX_LINES.
          - The patch must apply cleanly with `git apply` from repo root.
          - Prefer minimal edits; maintain existing code style.
          - If nothing needs changing, return an empty patch.
          EOS
          
          read -r -d '' REQ <<EOF || true
          TASK:
          $PROMPT
          
          PR diff (context):
          ```diff
          $DIFF
          ```
          
          CONSTRAINTS:
          - ALLOWLIST: $ALLOWED
          - MAX_LINES: $MAX
          
          Output ONLY the unified diff. No explanatory text.
          EOF
          
          if [ -z "${OPENAI_API_KEY:-}" ]; then
            : > patch.diff
            exit 0
          fi
          
          PAYLOAD=$(jq -n \
            --arg model "$MODEL" \
            --arg temp "$TEMP" \
            --arg max_tok "$MAXTOK" \
            --arg sys "$SYS" \
            --arg req "$REQ" \
            '{
              "model": $model,
              "temperature": ($temp | tonumber),
              "max_tokens": ($max_tok | tonumber),
              "messages": [
                {
                  "role": "system",
                  "content": $sys
                },
                {
                  "role": "user",
                  "content": $req
                }
              ]
            }')

          printf "%s" "$PAYLOAD" > /tmp/openai_patch_payload.json

          RESP=$(curl -s https://api.openai.com/v1/chat/completions \
            -H "content-type: application/json" \
            -H "authorization: Bearer $OPENAI_API_KEY" \
            -d @/tmp/openai_patch_payload.json)
          
          echo "$RESP" | jq -r '.choices[0].message.content // ""' > patch_raw.txt
          awk 'BEGIN{in=1} /^```/{in=!in; next} {if(in) print}' patch_raw.txt > patch.diff || true

      - name: Validate allowlist and limits
        if: steps.parse.outputs.run_mode != 'suggest'
        id: validate
        run: |
          set -euo pipefail
          . "$RUNNER_TEMP/allowlist.sh"
          
          ALLOWED=$(cat allowed.txt); [ -z "$ALLOWED" ] && ALLOWED='**'
          ALLOWED_REGEX=$(allowlist_to_regex "$ALLOWED")
          MAX=$(cat max.txt); [ -z "$MAX" ] && MAX=800
          if [ ! -s patch.diff ]; then
            echo "Empty patch â€“ nothing to process."
            echo "total_lines=0" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          
          # Extract changed paths
          CHANGED_PATHS=$(grep -E '^(\+\+\+|---)[[:space:]]' patch.diff \
            | sed -E 's@^(\+\+\+|---)[[:space:]][ab/]*@@' \
            | sed -E 's/([[:space:]].*)?$//' \
            | sort -u)
          
          # Block critical paths
          # Break down complex regex into readable components
          WORKFLOW_RE='^\.github/workflows/'
          LOCK_RE='\.lock$'
          IMAGE_RE='\.(png|jpg|gif|svg|ico)$'
          DOC_RE='\.(pdf|zip)$'
          ENV_RE='(^|/)\.env$'
          CERT_RE='\.(pem|key|crt|p12|pfx|der|csr|gpg|asc)$'
          # Combine all components into one regex
          DENY_RE="(${WORKFLOW_RE}|${LOCK_RE}|${IMAGE_RE}|${DOC_RE}|${ENV_RE}|${CERT_RE})"
          BLOCKED=$(echo "$CHANGED_PATHS" | grep -i -E "$DENY_RE" || true)
          if [ -n "$BLOCKED" ]; then
            echo "âŒ Patch touches blocked paths:" >&2
            echo "$BLOCKED" >&2
            exit 1
          fi
          
          # Check allowlist
          DISALLOWED=$(echo "$CHANGED_PATHS" | grep -vE "$ALLOWED_REGEX" || true)
          if [ -n "$DISALLOWED" ]; then
            echo "âŒ Patch touches files outside allowlist:" >&2
            echo "$DISALLOWED" >&2
            exit 1
          fi
          
          # Count changed lines
          TOTAL=$(grep -E '^[+-]' patch.diff | grep -Ev '^\+\+\+|^---' | wc -l | awk '{print $1}')
          if [ "$TOTAL" -gt "$MAX" ]; then
            echo "âŒ Patch exceeds max changed lines ($TOTAL > $MAX)" >&2
            exit 1
          fi
          
          echo "--- Verifying patch ---"
          git --no-pager apply --stat patch.diff
          git --no-pager apply --check patch.diff
          echo "--- Applying patch ---"
          git --no-pager apply patch.diff
          
          echo "total_lines=$TOTAL" >> "$GITHUB_OUTPUT"

      # ========================= APPLY MODE =========================
      - name: Guard apply mode (require explicit confirm)
        if: steps.parse.outputs.run_mode == 'apply' && inputs.confirm != 'apply'
        run: |
          echo "âš ï¸ Refusing to run in apply mode: confirm must equal 'apply'" >&2
          exit 1

      - name: Apply patch and push (apply mode)
        if: steps.parse.outputs.run_mode == 'apply' && steps.validate.outputs.total_lines != ''
        id: apply_commit
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          git --no-pager add -A
          if ! git diff --cached --quiet; then
            git --no-pager config user.name "claude-assistant[bot][${{ github.repository }}]"
            git --no-pager config user.email "claude-assistant[bot]@users.noreply.github.com"
            COMMIT_MSG="Apply Merglbot PR Assistant patch for PR #${{ steps.parse.outputs.pr_number }}"
            git --no-pager commit -m "$COMMIT_MSG"
  
            # Capture commit summary for reporting
            SUMMARY=$(git --no-pager log -1 --format='%s' 2>/dev/null || echo "Applied changes")
            echo "commit_summary=$SUMMARY" >> "$GITHUB_OUTPUT"
            echo "has_changes=true" >> "$GITHUB_OUTPUT"
            
            echo "Pushing changes to remote..."
            if ! git --no-pager push; then
              echo "âŒ Failed to push changes. Checking remote status..." >&2
              git --no-pager status
              git --no-pager log --oneline -5
              exit 1
            fi
            echo "âœ… Successfully pushed changes"
          else
            echo "No changes to commit after applying patch."
            echo "has_changes=false" >> "$GITHUB_OUTPUT"
          fi
          
      - name: Comment summary (apply mode)
        if: always() && steps.parse.outputs.run_mode == 'apply'
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          PR=${{ steps.parse.outputs.pr_number }}
          STATUS="${{ job.status }}"
          HAS_CHANGES="${{ steps.apply_commit.outputs.has_changes }}"
          COMMIT_SUMMARY="${{ steps.apply_commit.outputs.commit_summary }}"
          
          # Build comment body with safe substitution
          BODY=$(cat <<-'EOF'
          	## ðŸ¤– Merglbot PR Assistant - Apply Mode Complete
          	
          	Status: STATUS_PLACEHOLDER
          	
          	CHANGES_PLACEHOLDER
          	
          	RESULT_PLACEHOLDER
          	EOF
          )
          
          # Safe substitutions
          BODY="${BODY//STATUS_PLACEHOLDER/$STATUS}"
          
          if [ "$HAS_CHANGES" = "true" ] && [ -n "$COMMIT_SUMMARY" ]; then
            BODY="${BODY//CHANGES_PLACEHOLDER/**Changes:** $COMMIT_SUMMARY}"
          else
            BODY="${BODY//CHANGES_PLACEHOLDER/No changes were applied.}"
          fi
          
          if [ "$STATUS" = "success" ]; then
            BODY="${BODY//RESULT_PLACEHOLDER/âœ… Successfully applied changes.}"
          else
            BODY="${BODY//RESULT_PLACEHOLDER/âŒ Failed to apply changes.}"
          fi
          
          gh pr comment "$PR" --body "$BODY"
      - name: Create GitHub review suggestions (apply-suggestions)
        if: steps.parse.outputs.run_mode == 'apply-suggestions' && steps.validate.outputs.total_lines != ''
        id: suggest_apply
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          PR=${{ steps.parse.outputs.pr_number }}
          OWNER_REPO="$GITHUB_REPOSITORY"
          
          python3 "$RUNNER_TEMP/patch_to_review.py" < patch.diff > comments.json
          
          # Validate required variables before proceeding
          if [ -z "$OWNER_REPO" ] || [ -z "$PR" ]; then
            echo "âŒ Missing required variables: OWNER_REPO or PR" >&2
            exit 1
          fi
          # Validate formats: owner/repo and PR number
          if ! [[ "$OWNER_REPO" =~ ^[A-Za-z0-9][A-Za-z0-9-]*/[A-Za-z0-9_-][A-Za-z0-9._-]*$ ]]; then
            echo "âŒ Invalid OWNER_REPO format: '$OWNER_REPO'" >&2
            exit 1
          fi
          if ! [[ "$PR" =~ ^[0-9]+$ ]]; then
            echo "âŒ Invalid PR number: '$PR'" >&2
            exit 1
          fi
          
          # Calculate number of comments (handle both array and non-array cases)
          if [ ! -f comments.json ]; then
            echo "âš ï¸ comments.json file not found, no comments to process"
            COMMENTS_COUNT=0
          elif [ ! -s comments.json ]; then
            echo "âš ï¸ comments.json file is empty, no comments to process"
            COMMENTS_COUNT=0
          elif ! COMMENTS_COUNT=$(jq 'if type == "array" then length else 0 end' comments.json 2>/dev/null); then
            echo "âŒ Failed to parse comments.json, this indicates a workflow error" >&2
            exit 1
          fi
          
          if [ "$COMMENTS_COUNT" -gt 0 ]; then
            # If we have inline comments, create review with those comments
            jq '{event:"COMMENT", comments: .}' comments.json > review.json
            gh api repos/$OWNER_REPO/pulls/$PR/reviews --input review.json
            echo "âœ… Posted $COMMENTS_COUNT review suggestions."
          elif [ -s patch.diff ]; then
            # If we have a patch but no inline comments (e.g., new files),
            # create a review with a body comment explaining the changes
            # Count all added/removed lines (excluding diff metadata)
            LINES_CHANGED=$(grep -E '^[+-][^+-]' patch.diff | wc -l | awk '{print $1}')
            
            # Filter for meaningful content changes (additions and deletions):
            # Exclude whitespace-only and comment-only lines for BOTH '+' and '-'
            MEANINGFUL_CHANGES=$(grep -E '^[+-][^+-]' patch.diff \
              | grep -v -E '^[+-]\s*$' \
              | grep -v -E '^[+-]\s*#' \
              | grep -v -E '^[+-]\s*//' \
              | grep -v -E '^[+-]\s*/\*' \
              | grep -v -E '^[+-]\s*\*' \
              | grep -v -E '^[+-]\s*<!--' \
              | wc -l | awk '{print $1}')
            
            # Validate numeric result and skip non-substantive changes
            if ! [[ "$LINES_CHANGED" =~ ^[0-9]+$ ]]; then
              echo "âŒ Failed to calculate changed lines count: '$LINES_CHANGED' is not a number" >&2
              exit 1
            fi
            if ! [[ "$MEANINGFUL_CHANGES" =~ ^[0-9]+$ ]]; then
              echo "âŒ Failed to calculate meaningful changes count: '$MEANINGFUL_CHANGES' is not a number" >&2
              exit 1
            fi
            if [ "$MEANINGFUL_CHANGES" -eq 0 ]; then
              echo "âš ï¸ Patch exists but no meaningful content lines changed (possibly metadata, whitespace, or comments only), skipping review"
              exit 0
            fi
            
            # Generate review with helpful next steps for the user (use jq to avoid YAML/heredoc pitfalls)
            if ! jq -n --arg lines "$LINES_CHANGED" \
              '{
                event: "COMMENT",
                body: "ðŸ¤– **Merglbot PR Assistant Suggestions**\n\nI generated changes for this PR (" + $lines + " lines modified).\n\nâš ï¸ **Note:** The changes could not be converted to inline suggestions (possibly new files or complex edits).\n\n**Next steps:**\n- Review the full diff in the `Files changed` tab\n- Check the workflow artifacts for detailed patch files\n- Apply changes manually if appropriate\n\nFor questions, please check the workflow run details."
              }' > review.json; then
              echo "âš ï¸ Failed to generate review JSON" >&2
              exit 1
            fi
            # Validate that review.json is valid JSON
            if ! jq empty review.json; then
              echo "âš ï¸ Generated review.json is not valid JSON" >&2
              exit 1
            fi
            if ! gh api repos/$OWNER_REPO/pulls/$PR/reviews --input review.json; then
              echo "âŒ Failed to post review via GitHub API" >&2
              exit 1
            fi
            echo "âœ… Posted review comment with $LINES_CHANGED lines changed (no inline suggestions available)."
          else
            echo "No changes to suggest."
          fi

      # =================== GITHUB_STEP_SUMMARY ===================
      - name: Append to Step Summary
        if: always()
        run: |
          set -euo pipefail
          
          {
            echo "## ðŸ¤– Claude PR Assistant v2"
            echo
            echo "- **PR**: #${{ steps.parse.outputs.pr_number }}"
            echo "- **Mode**: ${{ steps.parse.outputs.run_mode }}"
            echo "- **Model**: ${{ steps.cfg.outputs.model }}"
            echo "- **Temperature**: ${{ steps.cfg.outputs.temperature }}"
            echo "- **OpenAI model**: ${{ steps.cfg.outputs.openai_model }} (enabled: ${{ inputs.enable_openai }})"
            echo "- **Patch provider**: ${{ steps.cfg.outputs.patch_provider }}"
            echo "- **Status**: ${{ job.status }}"
            
            if [ "${{ steps.validate.outputs.total_lines }}" != "" ]; then
              echo "- **Changed lines**: ${{ steps.validate.outputs.total_lines }}"
            fi
            
            echo
            echo "---"
            echo "*Reusable workflow from merglbot-core/github*"
          } >> "$GITHUB_STEP_SUMMARY"
