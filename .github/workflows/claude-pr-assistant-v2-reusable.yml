name: Claude PR Assistant v2 (Reusable Full-Featured)

on:
  workflow_call:
    inputs:
      pr_number:
        description: 'PR number (integer or full URL)'
        required: true
        type: string
      prompt:
        description: 'Custom instruction for assistant'
        required: false
        type: string
        default: |
          ProveÄ profesionÃ¡lnÃ­ code review tohoto PR. ZamÄ›Å™ se na: (1) bezpeÄnost (secrets, OIDC/WIF), (2) architekturnÃ­ konzistenci s WARP rules, (3) potenciÃ¡lnÃ­ bugy a edge cases, (4) kvalitu kÃ³du a idiomatiÄnost. OdpovÄ›z Äesky, kÃ³d komentuj anglicky. VÃ½stup: krÃ¡tkÃ½ sumÃ¡Å™ (3-5 Å™Ã¡dkÅ¯), seznam konkrÃ©tnÃ­ch findings (kaÅ¾dÃ½ s vysvÄ›tlenÃ­m a doporuÄenÃ­m), zÃ¡vÄ›r (schvÃ¡lit/changes needed).
      model:
        description: 'AI model'
        required: false
        type: string
        default: 'Sonnet 4.5 (doporuÄeno)'
      temperature:
        description: 'Sampling temperature (0.0-1.0)'
        required: false
        type: string
        default: '0.2'
      run_mode:
        description: 'Run mode: suggest (comments), apply-suggestions (review suggestions), apply (commit & push)'
        required: false
        type: string
        default: 'suggest'
      allowed_paths:
        description: 'Allowed path globs (comma-separated)'
        required: false
        type: string
        default: '**'
      max_changed_lines:
        description: 'Max changed lines for apply modes'
        required: false
        type: string
        default: '800'
      confirm:
        description: 'For apply mode: type "apply" to confirm'
        required: false
        type: string
    secrets:
      ANTHROPIC_API_KEY:
        required: true
      GH_TOKEN:
        required: false

  workflow_dispatch:
    inputs:
      pr_number:
        description: 'ÄŒÃ­slo PR (napÅ™. 20) NEBO plnÃ¡ URL (napÅ™. https://github.com/org/repo/pull/20)'
        required: true
        type: string
      prompt:
        description: 'VolitelnÃ¡ instrukce pro asistenta'
        required: false
        type: string
        default: |
          ProveÄ profesionÃ¡lnÃ­ code review tohoto PR. ZamÄ›Å™ se na: (1) bezpeÄnost (secrets, OIDC/WIF), (2) architekturnÃ­ konzistenci s WARP rules, (3) potenciÃ¡lnÃ­ bugy a edge cases, (4) kvalitu kÃ³du a idiomatiÄnost. OdpovÄ›z Äesky, kÃ³d komentuj anglicky. VÃ½stup: krÃ¡tkÃ½ sumÃ¡Å™ (3-5 Å™Ã¡dkÅ¯), seznam konkrÃ©tnÃ­ch findings (kaÅ¾dÃ½ s vysvÄ›tlenÃ­m a doporuÄenÃ­m), zÃ¡vÄ›r (schvÃ¡lit/changes needed).
      model:
        description: 'AI model - doporuÄeno: Sonnet 4.5 (vyvÃ¡Å¾enÃ½), Opus 4.1 (komplexnÃ­), Haiku 3.5 (rychlÃ½)'
        required: false
        type: choice
        default: 'Sonnet 4.5 (doporuÄeno)'
        options:
          - Sonnet 4.5 (doporuÄeno)
          - Opus 4.1 (komplexnÃ­)
          - Haiku 3.5 (rychlÃ½)
          - Opus 4.0
          - Sonnet 4.0
          - Sonnet 3.7
          - Sonnet 3.5 (stable)
          - Sonnet 3.5 (legacy)
          - Haiku 3.0
      temperature:
        description: 'Teplota vzorkovÃ¡nÃ­ (0.0-1.0, niÅ¾Å¡Ã­ = konzervativnÄ›jÅ¡Ã­ odpovÄ›di)'
        required: false
        type: number
        default: 0.2
      run_mode:
        description: 'ReÅ¾im bÄ›hu: suggest (komentÃ¡Å™e), apply-suggestions (review nÃ¡vrhy), apply (commit & push)'
        required: true
        type: choice
        default: suggest
        options:
          - suggest
          - apply-suggestions
          - apply
      allowed_paths:
        description: 'PovolenÃ© cesty (globs oddÄ›lenÃ© ÄÃ¡rkou)'
        required: false
        type: string
        default: '**'
      max_changed_lines:
        description: 'MaximÃ¡lnÃ­ poÄet zmÄ›nÄ›nÃ½ch Å™Ã¡dkÅ¯ pro apply reÅ¾imy'
        required: false
        type: number
        default: 800
      confirm:
        description: 'Pouze pro apply reÅ¾im: napiÅ¡ "apply" pro povolenÃ­ commit & push'
        required: false
        type: string

permissions:
  contents: write         # needed for git push (apply mode)
  pull-requests: write    # needed for comments and reviews
  id-token: write        # for WIF/OIDC (future)

concurrency:
  group: claude-assistant-v2-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  review:
    name: Claude PR Review
    runs-on: ubuntu-latest
    timeout-minutes: 15
    env:
      ANTHROPIC_API_VERSION: "2023-06-01"  # Centralized version, can be updated

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Parse inputs (PR and prompt)
        id: parse
        env:
          INPUT: ${{ inputs.pr_number }}
          PROMPT_INPUT: ${{ inputs.prompt }}
          RUN_MODE: ${{ inputs.run_mode }}
        run: |
          set -euo pipefail
          
          # Normalize run_mode (strip extra text if choice format)
          RUN_MODE_TRIM=$(printf "%s" "$RUN_MODE" | awk '{print $1}')
          echo "run_mode=$RUN_MODE_TRIM" >> "$GITHUB_OUTPUT"
          
          # Extract PR number from input (support both integer and URL)
          if [[ "$INPUT" =~ github\.com/.*/pull/([0-9]+) ]]; then
            PR_NUMBER="${BASH_REMATCH[1]}"
          elif [[ "$INPUT" =~ ^[0-9]+$ ]]; then
            PR_NUMBER="$INPUT"
          else
            echo "âŒ Invalid pr_number: $INPUT (expect PR integer or full URL)" >&2
            exit 1
          fi
          echo "pr_number=$PR_NUMBER" >> "$GITHUB_OUTPUT"
          
          # Prepare prompt file (no variable expansion)
          : "${PROMPT_INPUT:=Manual review requested via workflow}"
          PROMPT_FILE="$RUNNER_TEMP/prompt.txt"
          printf "%s\n" "$PROMPT_INPUT" > "$PROMPT_FILE"
          echo "prompt_file=$PROMPT_FILE" >> "$GITHUB_OUTPUT"

      - name: Prepare helper scripts
        id: helpers
        run: |
          set -euo pipefail
          
          # allowlist_to_regex: convert globs to ERE
          cat > "$RUNNER_TEMP/allowlist.sh" <<'SH'
          allowlist_to_regex() {
            # Input: comma-separated globs (e.g. "src/**,docs/**")
            # Output: single ERE joined by |
            printf "%s" "$1" | tr ',' '\n' \
              | sed -E 's/([.^$+?{}()|[\]\\])/\\\1/g; s@\*\*@.*@g; s@\*@[^/]*@g' \
              | paste -sd'|' -
          }
          SH
          
          # Python: unified-diff â†’ GitHub review suggestions
          cat > "$RUNNER_TEMP/patch_to_review.py" <<'PY'
          import re, json, sys
          # Named constants
          MAX_REVIEW_COMMENTS = 30  # GitHub API limit for review comments
          
          patch = sys.stdin.read().splitlines()
          comments = []
          current_file = None
          new_start = None
          new_count = None
          content = []

          def flush():
              if current_file and new_start is not None and content:
                  body = "".join(content)
                  count = new_count if new_count is not None else max(1, len(body.splitlines()))
                  end = new_start + count - 1
                  comments.append({
                      "path": current_file,
                      "side": "RIGHT",
                      "start_line": new_start,
                      "line": end,
                      "body": f"```suggestion\n{body}\n```",
                  })

          for line in patch:
              if line.startswith('+++ b/'):
                  current_file = line[6:]
                  continue
              if line.startswith('@@ '):
                  if content:
                      flush()
                      content = []
                  m = re.search(r"@@ -\d+(?:,\d+)? \+(\d+)(?:,(\d+))? @@", line)
                  if m:
                      new_start = int(m.group(1))
                      new_count = int(m.group(2)) if m.group(2) else None
                  else:
                      new_start, new_count = None, None
                  continue
              if line.startswith('+++') or line.startswith('--- '):
                  continue
              if line.startswith('+') and not line.startswith('+++'):
                  content.append(line[1:] + "\n")
              elif line.startswith(' ') and content:
                  content.append(line[1:] + "\n")

          if content:
              flush()

          comments = comments[:MAX_REVIEW_COMMENTS]
          json.dump(comments, sys.stdout)
          PY

      - name: Map model name to API identifier
        id: cfg
        env:
          MODEL_INPUT: ${{ inputs.model }}
          TEMP: ${{ inputs.temperature }}
          ALLOWED: ${{ inputs.allowed_paths }}
          MAX: ${{ inputs.max_changed_lines }}
        run: |
          set -euo pipefail
          
          # Map human-readable names to Anthropic API identifiers
          case "${MODEL_INPUT:-}" in
            "Sonnet 4.5 (doporuÄeno)") MODEL='claude-sonnet-4-5-20250929' ;;
            "Opus 4.1 (komplexnÃ­)")     MODEL='claude-opus-4-1-20250805' ;;
            "Haiku 3.5 (rychlÃ½)")       MODEL='claude-3-5-haiku-20241022' ;;
            "Opus 4.0")                 MODEL='claude-opus-4-20250514' ;;
            "Sonnet 4.0")               MODEL='claude-sonnet-4-20250514' ;;
            "Sonnet 3.7")               MODEL='claude-3-7-sonnet-20250219' ;;
            "Sonnet 3.5 (stable)")      MODEL='claude-3-5-sonnet-20241022' ;;
            "Sonnet 3.5 (legacy)")      MODEL='claude-3-5-sonnet-20240620' ;;
            "Haiku 3.0")                MODEL='claude-3-haiku-20240307' ;;
            *)                          MODEL='claude-sonnet-4-5-20250929' ;;  # safe fallback
          esac
          
          [ -z "${TEMP:-}" ] && TEMP='0.2'
          [ -z "${ALLOWED:-}" ] && ALLOWED='**'
          [ -z "${MAX:-}" ] && MAX='800'
          
          echo "model=$MODEL" >> "$GITHUB_OUTPUT"
          echo "temperature=$TEMP" >> "$GITHUB_OUTPUT"
          echo "$ALLOWED" > allowed.txt
          echo "$MAX" > max.txt

      # ======================== SUGGEST MODE ========================
      - name: Build PR diff (suggest mode)
        if: steps.parse.outputs.run_mode == 'suggest'
        id: pr_ctx
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          PR_NUMBER="${{ steps.parse.outputs.pr_number }}"
          gh pr diff "$PR_NUMBER" > pr_diff.txt || echo "No diff available" > pr_diff.txt
          wc -l pr_diff.txt || true

      - name: Call LLM (suggest mode)
        if: steps.parse.outputs.run_mode == 'suggest'
        id: call_suggest
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          set -euo pipefail
          # Named constants for input size limits
          MAX_COMMENT_CHARS=20000
          MAX_DIFF_LINES=8000
          
          COMMENT=$(cat '${{ steps.parse.outputs.prompt_file }}')
          MODEL='${{ steps.cfg.outputs.model }}'
          TEMP='${{ steps.cfg.outputs.temperature }}'
    
          # Escape for JSON
          COMMENT_SAFE=$(printf "%s" "$COMMENT" | head -c "$MAX_COMMENT_CHARS")
          COMMENT_JSON=$(printf "%s" "$COMMENT_SAFE" | jq -R -s '.')
          DIFF_CONTENT=$(head -n "$MAX_DIFF_LINES" pr_diff.txt)
          DIFF_JSON=$(printf "%s" "$DIFF_CONTENT" | jq -R -s '.')

          if [ -z "${ANTHROPIC_API_KEY:-}" ]; then
            printf "LLM not configured; posting diff summary only." > claude_response.txt
            exit 0
          fi
    
          # Note: The read -r -d '' heredoc always returns exit code 1, which causes failure with set -e
          # Since the PAYLOAD_TEMPLATE is not actually used (the real payload is built with jq below),
          # we can safely remove this heredoc

          PAYLOAD=$(jq -n \
            --arg model "$MODEL" \
            --arg temp "$TEMP" \
            --arg comment "$COMMENT_JSON" \
            --arg diff "$DIFF_JSON" \
            '{
              "model": $model,
              "max_tokens": 4096,
              "temperature": ($temp | tonumber),
              "messages": [
                {
                  "role": "user",
                  "content": [
                    {
                      "type": "text",
                      "text": "You are a helpful code reviewer.\nRules: no secrets in logs, least-privilege IAM, safe shell patterns, no destructive infra changes.\n\nUser request:\n"
                    },
                    {
                      "type": "text",
                      "text": $comment
                    },
                    {
                      "type": "text",
                      "text": "\n\nPR Diff:\n```\n"
                    },
                    {
                      "type": "text",
                      "text": $diff
                    },
                    {
                      "type": "text",
                      "text": "\n```"
                    }
                  ]
                }
              ]
            }')

          RESP=$(curl -s https://api.anthropic.com/v1/messages \
            -H "content-type: application/json" \
            -H "x-api-key: $ANTHROPIC_API_KEY" \
            -H "anthropic-version: ${ANTHROPIC_API_VERSION:-2023-06-01}" \
            -d "$PAYLOAD")
    
          printf "%s" "$RESP" > claude_api_suggest.json
          echo "$RESP" | jq -r '.content[0].text // ""' > claude_response.txt

      - name: Post comment (suggest mode)
        if: steps.parse.outputs.run_mode == 'suggest'
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          PR_NUMBER="${{ steps.parse.outputs.pr_number }}"
          
          if [ ! -s claude_response.txt ]; then
            {
              echo "## ðŸ¤– Claude Assistant"
              echo
              echo "No suggestions generated or LLM unavailable."
            } > comment_body.md
          else
            {
              echo "## ðŸ¤– Claude Assistant"
              echo
              cat claude_response.txt
              echo
              echo "---"
              echo "*AI-generated suggestions. Please review before applying.*"
            } > comment_body.md
          fi
          
          gh pr comment "$PR_NUMBER" --body-file comment_body.md

      # =============== APPLY/APPLY-SUGGESTIONS SHARED ===============
      - name: Fetch PR metadata
        if: steps.parse.outputs.run_mode != 'suggest'
        id: meta
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          PR="${{ steps.parse.outputs.pr_number }}"
          OWNER_REPO="$GITHUB_REPOSITORY"
          
          gh api repos/$OWNER_REPO/pulls/$PR > pr.json
          HEAD_REF=$(jq -r '.head.ref' pr.json)
          HEAD_REPO=$(jq -r '.head.repo.full_name' pr.json)
          BASE_REF=$(jq -r '.base.ref' pr.json)
          
          echo "head_ref=$HEAD_REF" >> "$GITHUB_OUTPUT"
          echo "head_repo=$HEAD_REPO" >> "$GITHUB_OUTPUT"
          echo "base_ref=$BASE_REF" >> "$GITHUB_OUTPUT"

      - name: Checkout PR head
        if: steps.parse.outputs.run_mode != 'suggest'
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.meta.outputs.head_repo || github.repository }}
          ref: ${{ steps.meta.outputs.head_ref }}
          fetch-depth: 0

      - name: Build context for patch generation
        if: steps.parse.outputs.run_mode != 'suggest'
        id: ctx
        run: |
          set -euo pipefail
          BASE_REF="${{ steps.meta.outputs.base_ref }}"
          git fetch --no-tags origin "$BASE_REF":"refs/remotes/origin/$BASE_REF"
          git --no-pager diff --unified=1 "origin/$BASE_REF...HEAD" > pr_diff.txt || true
          
          echo "${{ inputs.allowed_paths }}" > allowed.txt
          echo "${{ inputs.max_changed_lines }}" > max.txt

      - name: Ask LLM for unified patch
        if: steps.parse.outputs.run_mode != 'suggest'
        id: ask
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          set -euo pipefail
          # Named constants for diff limits
          MAX_DIFF_LINES=8000
          MAX_DIFF_CHARS=350000
          MODEL='${{ steps.cfg.outputs.model }}'
          TEMP='${{ steps.cfg.outputs.temperature }}'
          PROMPT=$(cat '${{ steps.parse.outputs.prompt_file }}')
          
          escape_for_prompt() { sed -e 's/[`$\\]/\\&/g'; }
          DIFF=$(head -n "$MAX_DIFF_LINES" pr_diff.txt | escape_for_prompt | head -c "$MAX_DIFF_CHARS")
          ALLOWED=$(cat allowed.txt)
          MAX=$(cat max.txt)
          
          read -r -d '' SYS <<'EOS' || true
          You are a cautious code editor that outputs a single valid unified diff patch.
          Rules:
          - Touch ONLY files under the allowlist globs provided.
          - Never modify .github/workflows, secrets, lock files, or binary assets.
          - Keep total added+removed lines <= MAX_LINES.
          - The patch must apply cleanly with \`git apply\` from repo root.
          - Prefer minimal edits; maintain existing code style.
          - If nothing needs changing, return an empty patch.
          EOS
          
          read -r -d '' REQ <<EOF || true
          TASK:
          $PROMPT
          
          PR diff (context):
          \`\`\`diff
          $DIFF
          \`\`\`
          
          CONSTRAINTS:
          - ALLOWLIST: $ALLOWED
          - MAX_LINES: $MAX
          
          Output ONLY the unified diff. No explanatory text.
          EOF
          
          if [ -z "${ANTHROPIC_API_KEY:-}" ]; then
            : > patch.diff
            exit 0
          fi
          
          # Prepare JSON payload with system and request prompts
          PAYLOAD=$(jq -n \
            --arg model "$MODEL" \
            --arg temp "$TEMP" \
            --arg sys "$SYS" \
            --arg req "$REQ" \
            '{
              "model": $model,
              "max_tokens": 4096,
              "temperature": ($temp | tonumber),
              "messages": [
                {
                  "role": "system",
                  "content": $sys
                },
                {
                  "role": "user",
                  "content": $req
                }
              ]
            }')

          RESP=$(curl -s https://api.anthropic.com/v1/messages \
            -H "content-type: application/json" \
            -H "x-api-key: $ANTHROPIC_API_KEY" \
            -H "anthropic-version: ${ANTHROPIC_API_VERSION:-2023-06-01}" \
            -d "$PAYLOAD")
          
          # Extract patch content from LLM response
          echo "$RESP" | jq -r '.content[0].text // .content // empty' > patch_raw.txt
  
          # Strip markdown code fences if present
          awk 'BEGIN{in=1} /^```/{in=!in; next} {if(in) print}' patch_raw.txt > patch.diff || true

      - name: Validate allowlist and limits
        if: steps.parse.outputs.run_mode != 'suggest'
        id: validate
        run: |
          set -euo pipefail
          . "$RUNNER_TEMP/allowlist.sh"
          
          ALLOWED=$(cat allowed.txt); [ -z "$ALLOWED" ] && ALLOWED='**'
          ALLOWED_REGEX=$(allowlist_to_regex "$ALLOWED")
          MAX=$(cat max.txt); [ -z "$MAX" ] && MAX=800
          if [ ! -s patch.diff ]; then
            echo "Empty patch â€“ nothing to process."
            echo "total_lines=0" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          
          # Extract changed paths
          CHANGED_PATHS=$(grep -E '^(\+\+\+|---)[[:space:]]' patch.diff \
            | sed -E 's@^(\+\+\+|---)[[:space:]][ab/]*@@' \
            | sed -E 's/([[:space:]].*)?$//' \
            | sort -u)
          
          # Block critical paths
          # Break down complex regex into readable components
          WORKFLOW_RE='^\.github/workflows/'
          LOCK_RE='\.lock$'
          IMAGE_RE='\.(png|jpg|gif|svg|ico)$'
          DOC_RE='\.(pdf|zip)$'
          ENV_RE='(^|/)\.env$'
          CERT_RE='\.(pem|key|crt|p12|pfx|der|csr|gpg|asc)$'
          # Combine all components into one regex
          DENY_RE="(${WORKFLOW_RE}|${LOCK_RE}|${IMAGE_RE}|${DOC_RE}|${ENV_RE}|${CERT_RE})"
          BLOCKED=$(echo "$CHANGED_PATHS" | grep -i -E "$DENY_RE" || true)
          if [ -n "$BLOCKED" ]; then
            echo "âŒ Patch touches blocked paths:" >&2
            echo "$BLOCKED" >&2
            exit 1
          fi
          
          # Check allowlist
          DISALLOWED=$(echo "$CHANGED_PATHS" | grep -vE "$ALLOWED_REGEX" || true)
          if [ -n "$DISALLOWED" ]; then
            echo "âŒ Patch touches files outside allowlist:" >&2
            echo "$DISALLOWED" >&2
            exit 1
          fi
          
          # Count changed lines
          TOTAL=$(grep -E '^[+-]' patch.diff | grep -Ev '^\+\+\+|^---' | wc -l | awk '{print $1}')
          if [ "$TOTAL" -gt "$MAX" ]; then
            echo "âŒ Patch exceeds max changed lines ($TOTAL > $MAX)" >&2
            exit 1
          fi
          
          echo "--- Verifying patch ---"
          git --no-pager apply --stat patch.diff
          git --no-pager apply --check patch.diff
          echo "--- Applying patch ---"
          git --no-pager apply patch.diff
          
          echo "total_lines=$TOTAL" >> "$GITHUB_OUTPUT"

      # ========================= APPLY MODE =========================
      - name: Guard apply mode (require explicit confirm)
        if: steps.parse.outputs.run_mode == 'apply' && inputs.confirm != 'apply'
        run: |
          echo "âš ï¸ Refusing to run in apply mode: confirm must equal 'apply'" >&2
          exit 1

      - name: Apply patch and push (apply mode)
        if: steps.parse.outputs.run_mode == 'apply' && steps.validate.outputs.total_lines != ''
        id: apply_commit
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          git --no-pager add -A
          if ! git diff --cached --quiet; then
            git --no-pager config user.name "claude-assistant[bot][${{ github.repository }}]"
            git --no-pager config user.email "claude-assistant[bot]@users.noreply.github.com"
            COMMIT_MSG="Apply Claude Assistant patch for PR #${{ steps.parse.outputs.pr_number }}"
            git --no-pager commit -m "$COMMIT_MSG"
  
            # Capture commit summary for reporting
            SUMMARY=$(git --no-pager log -1 --format='%s' 2>/dev/null || echo "Applied changes")
            echo "commit_summary=$SUMMARY" >> "$GITHUB_OUTPUT"
            echo "has_changes=true" >> "$GITHUB_OUTPUT"
            
            echo "Pushing changes to remote..."
            if ! git --no-pager push; then
              echo "âŒ Failed to push changes. Checking remote status..." >&2
              git --no-pager status
              git --no-pager log --oneline -5
              exit 1
            fi
            echo "âœ… Successfully pushed changes"
          else
            echo "No changes to commit after applying patch."
            echo "has_changes=false" >> "$GITHUB_OUTPUT"
          fi
          
      - name: Comment summary (apply mode)
        if: always() && steps.parse.outputs.run_mode == 'apply'
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          PR=${{ steps.parse.outputs.pr_number }}
          STATUS="${{ job.status }}"
          HAS_CHANGES="${{ steps.apply_commit.outputs.has_changes }}"
          COMMIT_SUMMARY="${{ steps.apply_commit.outputs.commit_summary }}"
          
          # Build comment body with safe substitution
          BODY=$(cat <<-'EOF'
          	## ðŸ¤– Claude Assistant - Apply Mode Complete
          	
          	Status: STATUS_PLACEHOLDER
          	
          	CHANGES_PLACEHOLDER
          	
          	RESULT_PLACEHOLDER
          	EOF
          )
          
          # Safe substitutions
          BODY="${BODY//STATUS_PLACEHOLDER/$STATUS}"
          
          if [ "$HAS_CHANGES" = "true" ] && [ -n "$COMMIT_SUMMARY" ]; then
            BODY="${BODY//CHANGES_PLACEHOLDER/**Changes:** $COMMIT_SUMMARY}"
          else
            BODY="${BODY//CHANGES_PLACEHOLDER/No changes were applied.}"
          fi
          
          if [ "$STATUS" = "success" ]; then
            BODY="${BODY//RESULT_PLACEHOLDER/âœ… Successfully applied changes.}"
          else
            BODY="${BODY//RESULT_PLACEHOLDER/âŒ Failed to apply changes.}"
          fi
          
          gh pr comment "$PR" --body "$BODY"
      - name: Create GitHub review suggestions (apply-suggestions)
        if: steps.parse.outputs.run_mode == 'apply-suggestions' && steps.validate.outputs.total_lines != ''
        id: suggest_apply
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          PR=${{ steps.parse.outputs.pr_number }}
          OWNER_REPO="$GITHUB_REPOSITORY"
          
          python3 "$RUNNER_TEMP/patch_to_review.py" < patch.diff > comments.json
          
          # Get the number of comments to post
          COMMENTS_COUNT=$(jq '. | length' comments.json)
          COMMENTS_COUNT=$(jq 'if type == "array" then length else 0 end' comments.json)
          if [ "$COMMENTS_COUNT" -gt 0 ]; then
            # If we have inline comments, create review with those comments
            jq '{event:"COMMENT", comments: .}' comments.json > review.json
            gh api repos/$OWNER_REPO/pulls/$PR/reviews --input review.json
            echo "âœ… Posted $COMMENTS_COUNT review suggestions."
          elif [ -s patch.diff ]; then
            # If we have a patch but no inline comments (e.g., new files),
            # create a review with a body comment explaining the changes
            LINES_CHANGED=$(grep -E '^[+-][^+-]' patch.diff | wc -l)
            jq -n --arg lines "$LINES_CHANGED" \
              '{
                event: "COMMENT",
                body: "ðŸ¤– **Claude Assistant Suggestions**\n\nI generated changes for this PR (" + $lines + " lines modified).\n\nThe changes couldn't be converted to inline suggestions (possibly new files or complex edits).\nPlease review the full diff carefully."
              }' > review.json
            gh api repos/$OWNER_REPO/pulls/$PR/reviews --input review.json
            echo "âœ… Posted review comment (no inline suggestions available)."
          else
            echo "No changes to suggest."
          fi

      # =================== GITHUB_STEP_SUMMARY ===================
      - name: Append to Step Summary
        if: always()
        run: |
          set -euo pipefail
          
          {
            echo "## ðŸ¤– Claude PR Assistant v2"
            echo
            echo "- **PR**: #${{ steps.parse.outputs.pr_number }}"
            echo "- **Mode**: ${{ steps.parse.outputs.run_mode }}"
            echo "- **Model**: ${{ steps.cfg.outputs.model }}"
            echo "- **Temperature**: ${{ steps.cfg.outputs.temperature }}"
            echo "- **Status**: ${{ job.status }}"
            
            if [ "${{ steps.validate.outputs.total_lines }}" != "" ]; then
              echo "- **Changed lines**: ${{ steps.validate.outputs.total_lines }}"
            fi
            
            echo
            echo "---"
            echo "*Reusable workflow from merglbot-core/github*"
          } >> "$GITHUB_STEP_SUMMARY"
