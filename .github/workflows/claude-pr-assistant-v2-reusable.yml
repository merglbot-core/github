name: Claude PR Assistant v2 (Reusable Full-Featured)

on:
  workflow_call:
    inputs:
      pr_number:
        description: 'PR number (integer or full URL)'
        required: true
        type: string
      prompt:
        description: 'Custom instruction for assistant'
        required: false
        type: string
        default: |
          Proveď profesionální code review tohoto PR. Zaměř se na: (1) bezpečnost (secrets, OIDC/WIF), (2) architekturní konzistenci s WARP rules, (3) potenciální bugy a edge cases, (4) kvalitu kódu a idiomatičnost. Odpověz česky, kód komentuj anglicky. Výstup: krátký sumář (3-5 řádků), seznam konkrétních findings (každý s vysvětlením a doporučením), závěr (schválit/changes needed).
      model:
        description: 'AI model'
        required: false
        type: string
        default: 'Sonnet 4.5 (doporučeno)'
      temperature:
        description: 'Sampling temperature (0.0-1.0)'
        required: false
        type: string
        default: '0.2'
      run_mode:
        description: 'Run mode: suggest (comments), apply-suggestions (review suggestions), apply (commit & push)'
        required: false
        type: string
        default: 'suggest'
      allowed_paths:
        description: 'Allowed path globs (comma-separated)'
        required: false
        type: string
        default: '**'
      max_changed_lines:
        description: 'Max changed lines for apply modes'
        required: false
        type: string
        default: '800'
      confirm:
        description: 'For apply mode: type "apply" to confirm'
        required: false
        type: string
    secrets:
      ANTHROPIC_API_KEY:
        required: true
      GH_TOKEN:
        required: false

  workflow_dispatch:
    inputs:
      pr_number:
        description: 'Číslo PR (např. 20) NEBO plná URL (např. https://github.com/org/repo/pull/20)'
        required: true
        type: string
      prompt:
        description: 'Volitelná instrukce pro asistenta'
        required: false
        type: string
        default: |
          Proveď profesionální code review tohoto PR. Zaměř se na: (1) bezpečnost (secrets, OIDC/WIF), (2) architekturní konzistenci s WARP rules, (3) potenciální bugy a edge cases, (4) kvalitu kódu a idiomatičnost. Odpověz česky, kód komentuj anglicky. Výstup: krátký sumář (3-5 řádků), seznam konkrétních findings (každý s vysvětlením a doporučením), závěr (schválit/changes needed).
      model:
        description: 'AI model - doporučeno: Sonnet 4.5 (vyvážený), Opus 4.1 (komplexní), Haiku 3.5 (rychlý)'
        required: false
        type: choice
        default: 'Sonnet 4.5 (doporučeno)'
        options:
          - Sonnet 4.5 (doporučeno)
          - Opus 4.1 (komplexní)
          - Haiku 3.5 (rychlý)
          - Opus 4.0
          - Sonnet 4.0
          - Sonnet 3.7
          - Sonnet 3.5 (stable)
          - Sonnet 3.5 (legacy)
          - Haiku 3.0
      temperature:
        description: 'Teplota vzorkování (0.0-1.0, nižší = konzervativnější odpovědi)'
        required: false
        type: number
        default: 0.2
      run_mode:
        description: 'Režim běhu: suggest (komentáře), apply-suggestions (review návrhy), apply (commit & push)'
        required: true
        type: choice
        default: suggest
        options:
          - suggest
          - apply-suggestions
          - apply
      allowed_paths:
        description: 'Povolené cesty (globs oddělené čárkou)'
        required: false
        type: string
        default: '**'
      max_changed_lines:
        description: 'Maximální počet změněných řádků pro apply režimy'
        required: false
        type: number
        default: 800
      confirm:
        description: 'Pouze pro apply režim: napiš "apply" pro povolení commit & push'
        required: false
        type: string

permissions:
  contents: write         # needed for git push (apply mode)
  pull-requests: write    # needed for comments and reviews
  id-token: write        # for WIF/OIDC (future)

concurrency:
  group: claude-assistant-v2-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  review:
    name: Claude PR Review
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Parse inputs (PR and prompt)
        id: parse
        env:
          INPUT: ${{ inputs.pr_number }}
          PROMPT_INPUT: ${{ inputs.prompt }}
          RUN_MODE: ${{ inputs.run_mode }}
        run: |
          set -euo pipefail
          
          # Normalize run_mode (strip extra text if choice format)
          RUN_MODE_TRIM=$(printf "%s" "$RUN_MODE" | awk '{print $1}')
          echo "run_mode=$RUN_MODE_TRIM" >> "$GITHUB_OUTPUT"
          
          # Extract PR number from input (support both integer and URL)
          if [[ "$INPUT" =~ github\.com/.*/pull/([0-9]+) ]]; then
            PR_NUMBER="${BASH_REMATCH[1]}"
          elif [[ "$INPUT" =~ ^[0-9]+$ ]]; then
            PR_NUMBER="$INPUT"
          else
            echo "❌ Invalid pr_number: $INPUT (expect PR integer or full URL)" >&2
            exit 1
          fi
          echo "pr_number=$PR_NUMBER" >> "$GITHUB_OUTPUT"
          
          # Prepare prompt file (no variable expansion)
          : "${PROMPT_INPUT:=Manual review requested via workflow}"
          PROMPT_FILE="$RUNNER_TEMP/prompt.txt"
          printf "%s\n" "$PROMPT_INPUT" > "$PROMPT_FILE"
          echo "prompt_file=$PROMPT_FILE" >> "$GITHUB_OUTPUT"

      - name: Prepare helper scripts
        id: helpers
        run: |
          set -euo pipefail
          
          # allowlist_to_regex: convert globs to ERE
          cat > "$RUNNER_TEMP/allowlist.sh" <<'SH'
          allowlist_to_regex() {
            # Input: comma-separated globs (e.g. "src/**,docs/**")
            # Output: single ERE joined by |
            printf "%s" "$1" | tr ',' '\n' \
              | sed -E 's/([.^$+?{}()|[\]\\])/\\\1/g; s@\*\*@.*@g; s@\*@[^/]*@g' \
              | paste -sd'|' -
          }
          SH
          
          # Python: unified-diff → GitHub review suggestions
          cat > "$RUNNER_TEMP/patch_to_review.py" <<'PY'
          import re, json, sys
          patch = sys.stdin.read().splitlines()
          comments = []
          current_file = None
          new_start = None
          new_count = None
          content = []

          def flush():
              if current_file and new_start is not None and content:
                  body = "".join(content)
                  count = new_count if new_count is not None else max(1, body.count("\n"))
                  end = new_start + count - 1
                  comments.append({
                      "path": current_file,
                      "side": "RIGHT",
                      "start_line": new_start,
                      "line": end,
                      "body": f"```suggestion\n{body}\n```",
                  })

          for line in patch:
              if line.startswith('+++ b/'):
                  current_file = line[6:]
                  continue
              if line.startswith('@@ '):
                  if content:
                      flush()
                      content = []
                  m = re.search(r"@@ -\d+(?:,\d+)? \+(\d+)(?:,(\d+))? @@", line)
                  if m:
                      new_start = int(m.group(1))
                      new_count = int(m.group(2)) if m.group(2) else None
                  else:
                      new_start, new_count = None, None
                  continue
              if line.startswith('+++') or line.startswith('--- '):
                  continue
              if line.startswith('+') and not line.startswith('+++'):
                  content.append(line[1:] + "\n")
              elif line.startswith(' ') and content:
                  content.append(line[1:] + "\n")

          if content:
              flush()

          comments = comments[:30]  # GitHub API limit
          json.dump(comments, sys.stdout)
          PY

      - name: Map model name to API identifier
        id: cfg
        env:
          MODEL_INPUT: ${{ inputs.model }}
          TEMP: ${{ inputs.temperature }}
          ALLOWED: ${{ inputs.allowed_paths }}
          MAX: ${{ inputs.max_changed_lines }}
        run: |
          set -euo pipefail
          
          # Map human-readable names to Anthropic API identifiers
          case "${MODEL_INPUT:-}" in
            "Sonnet 4.5 (doporučeno)") MODEL='claude-sonnet-4-5-20250929' ;;
            "Opus 4.1 (komplexní)")     MODEL='claude-opus-4-1-20250805' ;;
            "Haiku 3.5 (rychlý)")       MODEL='claude-3-5-haiku-20241022' ;;
            "Opus 4.0")                 MODEL='claude-opus-4-20250514' ;;
            "Sonnet 4.0")               MODEL='claude-sonnet-4-20250514' ;;
            "Sonnet 3.7")               MODEL='claude-3-7-sonnet-20250219' ;;
            "Sonnet 3.5 (stable)")      MODEL='claude-3-5-sonnet-20241022' ;;
            "Sonnet 3.5 (legacy)")      MODEL='claude-3-5-sonnet-20240620' ;;
            "Haiku 3.0")                MODEL='claude-3-haiku-20240307' ;;
            *)                          MODEL='claude-sonnet-4-5-20250929' ;;  # safe fallback
          esac
          
          [ -z "${TEMP:-}" ] && TEMP='0.2'
          [ -z "${ALLOWED:-}" ] && ALLOWED='**'
          [ -z "${MAX:-}" ] && MAX='800'
          
          echo "model=$MODEL" >> "$GITHUB_OUTPUT"
          echo "temperature=$TEMP" >> "$GITHUB_OUTPUT"
          echo "$ALLOWED" > allowed.txt
          echo "$MAX" > max.txt

      # ======================== SUGGEST MODE ========================
      - name: Build PR diff (suggest mode)
        if: steps.parse.outputs.run_mode == 'suggest'
        id: pr_ctx
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          PR_NUMBER="${{ steps.parse.outputs.pr_number }}"
          gh pr diff "$PR_NUMBER" > pr_diff.txt || echo "No diff available" > pr_diff.txt
          wc -l pr_diff.txt || true

      - name: Call LLM (suggest mode)
        if: steps.parse.outputs.run_mode == 'suggest'
        id: call_suggest
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          set -euo pipefail
          COMMENT=$(cat '${{ steps.parse.outputs.prompt_file }}')
          MODEL='${{ steps.cfg.outputs.model }}'
          TEMP='${{ steps.cfg.outputs.temperature }}'
    
          # Escape for JSON
          escape_json() { jq -R -s '.' ; }
          COMMENT_JSON=$(printf "%s" "$COMMENT" | head -c 20000 | escape_json)
          DIFF_CONTENT=$(head -n 8000 pr_diff.txt | head -c 350000)
          DIFF_JSON=$(printf "%s" "$DIFF_CONTENT" | escape_json)

          if [ -z "${ANTHROPIC_API_KEY:-}" ]; then
            printf "LLM not configured; posting diff summary only." > claude_response.txt
            exit 0
          fi
    
          read -r -d '' PAYLOAD_TEMPLATE <<EOF
          {
            "model": "%s",
            "max_tokens": 4096,
            "temperature": %s,
            "messages": [
              {
                "role": "user",
                "content": [
                  {
                    "type": "text",
                    "text": "You are a helpful code reviewer.\\nRules: no secrets in logs, least-privilege IAM, safe shell patterns, no destructive infra changes.\\n\\nUser request:\\n"
                  },
                  {
                    "type": "text",
                    "text": %s
                  },
                  {
                    "type": "text",
                    "text": "\\n\\nPR Diff:\\n\`\`\`\\n"
                  },
                  {
                    "type": "text",
                    "text": %s
                  },
                  {
                    "type": "text",
                    "text": "\\n\`\`\`"
                  }
                ]
              }
            ]
          }
          EOF

          PAYLOAD=$(printf "$PAYLOAD_TEMPLATE" "$MODEL" "$TEMP" "$COMMENT_JSON" "$DIFF_JSON")

          RESP=$(curl -s https://api.anthropic.com/v1/messages \
            -H "content-type: application/json" \
            -H "x-api-key: $ANTHROPIC_API_KEY" \
            -H "anthropic-version: 2023-06-01" \
            -d "$PAYLOAD")
    
          printf "%s" "$RESP" > claude_api_suggest.json
          echo "$RESP" | jq -r '.content[0].text // ""' > claude_response.txt

      - name: Post comment (suggest mode)
        if: steps.parse.outputs.run_mode == 'suggest'
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          PR_NUMBER="${{ steps.parse.outputs.pr_number }}"
          
          if [ ! -s claude_response.txt ]; then
            {
              echo "## 🤖 Claude Assistant"
              echo
              echo "No suggestions generated or LLM unavailable."
            } > comment_body.md
          else
            {
              echo "## 🤖 Claude Assistant"
              echo
              cat claude_response.txt
              echo
              echo "---"
              echo "*AI-generated suggestions. Please review before applying.*"
            } > comment_body.md
          fi
          
          gh pr comment "$PR_NUMBER" --body-file comment_body.md

      # =============== APPLY/APPLY-SUGGESTIONS SHARED ===============
      - name: Fetch PR metadata
        if: steps.parse.outputs.run_mode != 'suggest'
        id: meta
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          PR="${{ steps.parse.outputs.pr_number }}"
          OWNER_REPO="$GITHUB_REPOSITORY"
          
          gh api repos/$OWNER_REPO/pulls/$PR > pr.json
          HEAD_REF=$(jq -r '.head.ref' pr.json)
          HEAD_REPO=$(jq -r '.head.repo.full_name' pr.json)
          BASE_REF=$(jq -r '.base.ref' pr.json)
          
          echo "head_ref=$HEAD_REF" >> "$GITHUB_OUTPUT"
          echo "head_repo=$HEAD_REPO" >> "$GITHUB_OUTPUT"
          echo "base_ref=$BASE_REF" >> "$GITHUB_OUTPUT"

      - name: Checkout PR head
        if: steps.parse.outputs.run_mode != 'suggest'
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.meta.outputs.head_repo || github.repository }}
          ref: ${{ steps.meta.outputs.head_ref }}
          fetch-depth: 0

      - name: Build context for patch generation
        if: steps.parse.outputs.run_mode != 'suggest'
        id: ctx
        run: |
          set -euo pipefail
          BASE_REF="${{ steps.meta.outputs.base_ref }}"
          git fetch --no-tags origin "$BASE_REF":"refs/remotes/origin/$BASE_REF"
          git --no-pager diff --unified=1 "origin/$BASE_REF...HEAD" > pr_diff.txt || true
          
          echo "${{ inputs.allowed_paths }}" > allowed.txt
          echo "${{ inputs.max_changed_lines }}" > max.txt

      - name: Ask LLM for unified patch
        if: steps.parse.outputs.run_mode != 'suggest'
        id: ask
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          set -euo pipefail
          MODEL='${{ steps.cfg.outputs.model }}'
          TEMP='${{ steps.cfg.outputs.temperature }}'
          PROMPT=$(cat '${{ steps.parse.outputs.prompt_file }}')
          
          escape_for_prompt() { sed -e 's/[`$\\]/\\&/g'; }
          DIFF=$(head -n 8000 pr_diff.txt | escape_for_prompt | head -c 350000)
          ALLOWED=$(cat allowed.txt)
          MAX=$(cat max.txt)
          
          read -r -d '' SYS <<'EOS' || true
          You are a cautious code editor that outputs a single valid unified diff patch.
          Rules:
          - Touch ONLY files under the allowlist globs provided.
          - Never modify .github/workflows, secrets, lock files, or binary assets.
          - Keep total added+removed lines <= MAX_LINES.
          - The patch must apply cleanly with \`git apply\` from repo root.
          - Prefer minimal edits; maintain existing code style.
          - If nothing needs changing, return an empty patch.
          EOS
          
          read -r -d '' REQ <<EOF || true
          TASK:
          $PROMPT
          
          PR diff (context):
          \`\`\`diff
          $DIFF
          \`\`\`
          
          CONSTRAINTS:
          - ALLOWLIST: $ALLOWED
          - MAX_LINES: $MAX
          
          Output ONLY the unified diff. No explanatory text.
          EOF
          
          if [ -z "${ANTHROPIC_API_KEY:-}" ]; then
            : > patch.diff
            exit 0
          fi
          
          # Prepare JSON payload with system and request prompts
          PAYLOAD=$(jq -n \
            --arg model "$MODEL" \
            --argjson temp "$TEMP" \
            --arg sys "$SYS" \
            --arg req "$REQ" \
            '{
              "model": $model,
              "max_tokens": 4096,
              "temperature": $temp,
              "messages": [
                {
                  "role": "system",
                  "content": $sys
                },
                {
                  "role": "user",
                  "content": $req
                }
              ]
            }')

          RESP=$(curl -s https://api.anthropic.com/v1/messages \
            -H "content-type: application/json" \
            -H "x-api-key: $ANTHROPIC_API_KEY" \
            -H "anthropic-version: 2023-06-01" \
            -d "$PAYLOAD")
  
          # Extract patch content from LLM response
          echo "$RESP" | jq -r '.content[0].text // .content // empty' > patch_raw.txt
  
          # Strip markdown code fences if present
          awk 'BEGIN{in=1} /^```/{in=!in; next} {if(in) print}' patch_raw.txt > patch.diff || true
          # Extract changed paths
          CHANGED_PATHS=$(grep -E '^(\+\+\+|---) ' patch.diff \
            | sed -E 's/^(---|\+\+\+) [ab]\///;s/\t.*//' \
            | sort -u)

      - name: Validate allowlist and limits
        if: steps.parse.outputs.run_mode != 'suggest'
        id: validate
        run: |
          set -euo pipefail
          . "$RUNNER_TEMP/allowlist.sh"
          
          ALLOWED=$(cat allowed.txt); [ -z "$ALLOWED" ] && ALLOWED='**'
          ALLOWED_REGEX=$(allowlist_to_regex "$ALLOWED")
          MAX=$(cat max.txt); [ -z "$MAX" ] && MAX=800
          
          if [ ! -s patch.diff ]; then 
            echo "Empty patch – nothing to process."
            exit 0
          fi
          
          # Extract changed paths
          CHANGED_PATHS=$(grep -E '^(\+\+\+|---)[[:space:]]' patch.diff \
            | sed -E 's@^(\+\+\+|---)[[:space:]][ab/]*@@' \
            | sed -E 's/([[:space:]].*)?$//' \
            | sort -u)
          
          # Block critical paths
          DENY_RE='(^\.github/workflows/|\.lock$|\.(png|jpg|gif|svg|ico|pdf|zip)$)'
          BLOCKED=$(echo "$CHANGED_PATHS" | grep -E "$DENY_RE" || true)
          if [ -n "$BLOCKED" ]; then
            echo "❌ Patch touches blocked paths:" >&2
            echo "$BLOCKED" >&2
            exit 1
          fi
          
          # Check allowlist
          DISALLOWED=$(echo "$CHANGED_PATHS" | grep -vE "$ALLOWED_REGEX" || true)
          if [ -n "$DISALLOWED" ]; then
            echo "❌ Patch touches files outside allowlist:" >&2
            echo "$DISALLOWED" >&2
            exit 1
          fi
          
          # Count changed lines
          TOTAL=$(grep -E '^[+-]' patch.diff | grep -Ev '^\+\+\+|^---' | wc -l | awk '{print $1}')
          if [ "$TOTAL" -gt "$MAX" ]; then
            echo "❌ Patch exceeds max changed lines ($TOTAL > $MAX)" >&2
            exit 1
          fi
          
          echo "--- Verifying patch ---"
          git --no-pager apply --stat patch.diff
          git --no-pager apply --check patch.diff
          echo "--- Applying patch ---"
          
          echo "total_lines=$TOTAL" >> "$GITHUB_OUTPUT"

      # ========================= APPLY MODE =========================
      - name: Guard apply mode (require explicit confirm)
        if: steps.parse.outputs.run_mode == 'apply' && inputs.confirm != 'apply'
        run: |
          echo "⚠️ Refusing to run in apply mode: confirm must equal 'apply'" >&2
          exit 1

      - name: Apply patch and push (apply mode)
        if: steps.parse.outputs.run_mode == 'apply' && steps.validate.outputs.total_lines != ''
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          git --no-pager add -A
    
          # Check if there are changes to commit
          if ! git diff --cached --quiet; then
            git --no-pager config user.name "claude-assistant[bot]"
            git --no-pager config user.email "claude-assistant[bot]@users.noreply.github.com"
            git --no-pager commit -m "Apply Claude Assistant patch for PR #${{ steps.parse.outputs.pr_number }}"
            git --no-pager push || { echo "❌ Failed to push changes" >&2; exit 1; }
          else
            echo "No changes to commit after applying patch."
          fi
          

      - name: Comment summary (apply mode)
        if: always() && steps.parse.outputs.run_mode == 'apply'
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          PR=${{ steps.parse.outputs.pr_number }}
          STATUS="${{ job.status }}"
          SUMMARY=$(git --no-pager log -1 --pretty=oneline 2>/dev/null || true)
          
          gh pr comment "$PR" --body "AI apply workflow finished with status: $STATUS

          Commit summary:
          \`\`\`
          $SUMMARY
          \`\`\`

          If unexpected, revert using PR history."

      # =================== APPLY-SUGGESTIONS MODE ===================
      - name: Create GitHub review suggestions (apply-suggestions)
        if: steps.parse.outputs.run_mode == 'apply-suggestions' && steps.validate.outputs.total_lines != ''
        id: suggest_apply
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          PR=${{ steps.parse.outputs.pr_number }}
          OWNER_REPO="$GITHUB_REPOSITORY"
          
          python3 "$RUNNER_TEMP/patch_to_review.py" < patch.diff > comments.json
          
          if [ -s comments.json ]; then
            jq '{event:"COMMENT", comments: .}' comments.json > review.json
            gh api repos/$OWNER_REPO/pulls/$PR/reviews --input review.json
            echo "✅ Posted review suggestions."
          else
            echo "No suggestions to post."
          fi

      # =================== GITHUB_STEP_SUMMARY ===================
      - name: Append to Step Summary
        if: always()
        run: |
          set -euo pipefail
          
          {
            echo "## 🤖 Claude PR Assistant v2"
            echo
            echo "- **PR**: #${{ steps.parse.outputs.pr_number }}"
            echo "- **Mode**: ${{ steps.parse.outputs.run_mode }}"
            echo "- **Model**: ${{ steps.cfg.outputs.model }}"
            echo "- **Temperature**: ${{ steps.cfg.outputs.temperature }}"
            echo "- **Status**: ${{ job.status }}"
            
            if [ "${{ steps.validate.outputs.total_lines }}" != "" ]; then
              echo "- **Changed lines**: ${{ steps.validate.outputs.total_lines }}"
            fi
            
            echo
            echo "---"
            echo "*Reusable workflow from merglbot-core/github*"
          } >> "$GITHUB_STEP_SUMMARY"
